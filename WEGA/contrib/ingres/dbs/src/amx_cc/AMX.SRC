000	can't write string value "%s"~
001	cannot create tmp stream~
002	invalid type %d of variable `%s'~
004	Interrupt~
005	You are not a valid %s user~
006	BACKUP: peek buffer overflow~
007	database `%s' not accessable~
008	FIND relation `%s'~
009	database `%s' does not exist~
010	can't get core for relation `%s'~
012	`%s' protected~
013	cannot open tmp stream~
014	`%s' has integrities~
015	can't get core for symbol `%s'~
016	`%s' is a view~
017	cannot read scan stream~
018	FIND index `%s'~
019	cannot create scan stream~
020	GET index `%s'~
021	missing %d doms in `%s'~
022	FIND attributes for `%s'~
023	dom %d in `%s' redeclared~
024	invalid dom #`%d' in `%s'~
025	AArelease(AA_%d);
~
026	} /@ %2d @@  end  of local RETRIEVE block @/
~
# ifdef MSC
028	IX entry~
# else
028	int		AAuid =		%s;
~
# endif
# ifdef MSC
029	IX entry~
# else
029	int		AAgid =		%s;
~
# endif
# ifdef MSC
030	char		@Usercode =	"%s";
# else
030	char		@AAusercode =	"%s";
# endif
~
# ifdef MSC
031	char		@Pathname = 	"%s";
# else
031	char		@AApath =	"%s";
# endif
~
# ifdef MSC
032	char		@Dbpath[] =
		{
# else
032	char		@AAdbpath =	"%s";
# endif
~
# ifdef IXF
033	MAIN__()
{
	extern int	xargc;
	extern char	@@xargv;
# else
033	main(xargc,xargv,e)
int	xargc;
char	@xargv[];
char	@e[];
{
# endif
~
035	static int		AAbufs[%d];
~
036	AAmain(AAbufs,%d,%d);
~
037	AAmain((char@)0,0,%d);
~
# ifdef IXF
038	amx_();
# else
038	amx(xargc,xargv,e);
# endif
# ifndef MSC
fflush(stdout);
# endif
exit(0);
}
~
040	AAbmove(%s,&AA_var,%d);
~
041	%s&AA_var) = %s&AA_var);
~
042	%s&AA_var) = %s;
~
043	AAset%s(AA_%d,AA_s%ckey,%s,%d,0%o);
~
045	AAopenr(&AA_%d,AA_%dn);
~
046	AAcloser(&AA_%d,AA_%dn);
~
047	AAbmove(&AA_STUP[%d],&AA_var,%d);
~
049	# include	"%s/lib/amx.h"
~
050	non terminated comment~
051	long	AA_htid;
~
052	{ /@ %2d @@ begin of local  REPLACE block @/
~
# ifdef MSC
054	IX entry~
# else
054	GET `protect'~
# endif
055	AAsetind(AA_%d,AA_i1key,&AA_s1key[%d],%d,0%o);
~
057	AArequest(AA_%d,AA_%dn);
~
# ifdef MSC
058	IX entry~
059	IX entry~
# else
058	can't get core for permits of relation `%s'~
# endif
# ifdef MSC
060	IX entry~
# else
060	AAPuser();
~
# endif
# ifdef MSC
061	IX entry~
# else
061	AAPgroup();
~
# endif
062	%s = AAtupcount(AA_%d);
~
063	cannot convert char to numeric~
064	AAsetind(AA_%d,AA_i2key,&AA_s2key[%d],%d,0%o);
~
# ifdef MSC
066	tTrace(xargv,'A',tT,100);
# else
066	AAtTrace(&xargc,xargv,'A');
# endif
~
067	cannot open index catalog~
068	AAlock(AA_%d,AA_%dn,%d);
~
069	AAunlock(1);
~
070	variable `%s' not declared~
071	too many variables used for amx (variable `%s')~
073	duplicate declaration of variable `%s'~
075	no scan relation for domain `%s'~
077	domain `%s.$%s' not declared~
078	no scan relation for domain `%d'~
080	domain `%s.$%d' not declared~
081	name `%s' too long~
082	relation `%s' not declared~
083	if (AADEADLOCK)
~
084	number too long~
085	floating conversion error `%s'~
086	integer conversion error `%s'~
087	unknown operator `%s'~
088	syntax error~
089	cannot scan relation `%s' over `%s'~
091	illegal conditions:%s%s~
092	string too long~
093	non terminated string~
094	system catalog `%s': cannot %s~
095	AA_STUP = AA_stup;
~
096	index `%s': cannot %s~
097	relation `%s': cannot %s~
098	} /@  end  of SCAN @/
~
099	goto AA%05d;
~
100	cannot assign scan domain to `%s'~
102	cannot open index `%s'~
103	cannot exec %s~
104	cannot close index `%s'~
105	AA_%ctid = AA_LOW;
~
106	unknown flag `%s'~
107	AA_htid = AA_HIGH;
~
108	bad flag format `%s'~
109	AA_stid = AA_LOW;
~
110	tuplecount variable `%s' must be numeric~
112	`char %s' not supported~
113	AA_STUP = AA_ptup;
~
114	`%s @%s' not supported~
115	AA_stup = AA_STUP;
~
116	`%s %s[]' not supported~
117	char	AA_i2key[%d];
~
118	AAabort();
~
119	char	AA_i1key[%d];
~
# if S_ALIGN > 0
120	short	AA_align;
~
# endif
# if L_ALIGN > 0
120	long	AA_align;
~
# endif
# if D_ALIGN > 0
120	double	AA_align;
~
# endif
121	char	AA_s2key[%d];
~
122	missing RETRIEVE for NEXTRETRIEVE~
124	missing RETRIEVE for ENDRETRIEVE~
126	double		AA_var;
~
127	long		AA_LOW;
~
128	long		AA_HIGH;
~
129	char		@AA_STUP;
~
130	char	AA_s1key[%d];
~
131	))
if (AAgetid(AA_%d,&AA_stid,AA_sgiven~
133	while (AAgetup(AA_%d,AA_%cgiven,&AA_%ctid,&AA_htid~
135	cannot fork %s~
136	%s terminated abnormal~
137	AAhisam(AA_%d,&AA_htid,AA_%cgiven,AA_%c1key);
~
139	AAlisam(AA_%d,&AA_%ctid,AA_%cgiven,AA_%c1key~
141	AAisam(AA_%d,&AA_%ctid,&AA_htid,AA_%cgiven,AA_%c1key);
~
143	AAhash(AA_%d,&AA_%ctid,&AA_htid,AA_%c1key);
~
145	AAbmove(AA_%d+%d,AA_igiven,%d);
~
147	AAbmove(AA_%d+%d,AA_sgiven,%d);
~
149	char	AA_igiven[%d];
~
150	{ /@ %2d @@ begin of local   APPEND block @/
~
152	char	AA_ptup[%d];
~
153	AAbmove(AA_STUP,AA_ptup,%d);
~
154	AAappend(AA_%d,AA_%dn,AA_ptup);
~
156	AAopeni(&AA_%d,AA_%dn,AA_%di);
~
157	%s = AAtuplength(AA_%d);
~
158	} /@ %2d @@  end  of local   APPEND block @/
~
160	{ /@ %2d @@ begin of local   DELETE block @/
~
162	AAdelete(AA_%d,AA_%dn,&AA_stid);
~
164	} /@ %2d @@  end  of local   DELETE block @/
~
166	char		AA_%di[] =	"~
167	extern char	AA_%di[];
~
168	char		@AA_%d;
~
169	extern char	@AA_%d;
~
170	char		AA_%dn[] =	"%s";
~
171	extern char	AA_%dn[];
~
172	{ /@ %2d @@ begin of local RETRIEVE block @/
~
174	char	@AA_stup;
~
175	long	AA_stid;
~
176	AAreplace(AA_%d,AA_%dn,&AA_stid,AA_ptup,"%s");
~
178	} /@ %2d @@  end  of local  REPLACE block @/
~
180	AAclearkeys(AA_%d,AA_%dn);
~
181	long	AA_itid;
~
182	invalid no of args~
183	AAclrtup(AA_%d,AA_%dn,AA_ptup);
~
185	cannot open %s~
186	compiling aborted~
187	char	AA_sgiven[%d];
~
188	cannot open input `%s'~
189	missing RETRIEVE for APPEND~
190	missing RETRIEVE for DELETE~
191	cannot change mode of %s to %d~
192	cannot compile because of AMX errors~
194	can't get core for arguments `%d'~
196	cannot convert numeric to char~
197	tuplelength variable `%s' must be numeric~
199	missing RETRIEVE for REPLACE~
200	AA_%d=(char@)0;
~
# ifdef MSC
201				(char@)0
		};
~
# else
201	MSC entry~
# endif
202	AA%05d:
~
203	))
{ /@ begin of SCAN @/
~
# ifdef MSC
204	char		@Database = 	"%s";
~
# else
204	MSC entry~
# endif
# ifdef MSC
205	short		tT[100];
~
# else
205	MSC entry~
# endif
# ifdef MSC
206				"%s",
~
# else
206	MSC entry~
# endif
207	Illegal ISAM-relation %.12s
~
208	{ /@ AMX-BEGIN @/
~
209	} /@ AMX-END @/
~
210	AAexit();
~
211	missing RETRIEVE for PRINT~
212	EXIT inside a RETRIEVE~
213	AA_stid = %s;
if (AAget(AA_%d,&AA_stid~
215	variable `%s' must be of tid type~
217	%s = AA_stid;
~
218	DUMMY entry for msg()~
