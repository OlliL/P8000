.ds RF \f3\*(xx\\f1
.ds LH Referenz-Manual
.ds RH \f3Uebersicht\f1 
.ds CH - % -
.bp
.NH 2
.ft B
Datenbank-\*(xx\-Kommandos *
.ft R
.LP
.sp 10
.NH 3
.ft B
\o'U"'bersicht zu den Kommandos unter \*(xx\ *
.ft R
.LP
Im Gegensatz zu den Kommandos der Anfragesprache QUEL
k\o'o"'nnen und m\o'u"'ssen einige anspruchsvollere
Kommandos auf dem Niveau der Shell eingegeben
werden, d.h., w\o'a"'hrend die QUEL-Kommandos erst
nach dem Eintreten in das Datenbanksystem durch
.ft B
quel
.ft R
"dbname"
abgearbeitet werden k\o'o"'nnen, sind die \*(xx\-Kommandos
unmittelbar nach dem 
.ft B 
login:
.ft R
verf\o'u"'gbar.
.LP
Bei den Kommandos,
.DS I
destroydb, purge, restore, sysmod,
.DE
die nur vom DBA ausgef\o'u"'hrt werden k\o'o"'nnen,
wird das alter/ego-Flag in der speziellen Form 
.DS I
-s
.DE
bereitgestellt.
.br
Das -s-Flag kann nur vom Systemadministrator angewendet werden
und gibt ihm die Rechte des DBA.
.br
In den Beschreibungen werden diese Flags
nicht mehr dokumentiert.
.LP
Zum Inhalt:
.IP =>
-AMX(\*(xx\) \- AMX-Schnittstelle zu C
.br
.ft B 
amx
.ft R
{ [
.ft B
flags
.ft R
] filename }
.br
.IP =>
-COPYDB(\*(xx\) \- kopiere eine Datenbank
.br
.ft B
copydb
.ft R
[
.ft B
flags
.ft R
] dbname directory
.br
{ relname }
.IP =>
.ft B
-copyr
.ft R
[
.ft B
flags
.ft R
] dbname relname
.br
{ domname = fformat } from | into
.br
filename | "#"
.IP =>
-EQC(\*(xx\) \- QUEL-Schnittstelle zu C
.br
.ft B
eqc 
.ft R
{ [
.ft B
flags
.ft R
] file.q }
.IP =>
-CREATDB(\*(xx\) \- erzeuge eine Datenbank
.br
.ft B
creatdb
.ft R
[
.ft B
flags
.ft R
] dbname
.IP =>
.ft B
-creater
.ft R
[
.ft B
flags
.ft R
] dbname relname {domname fformat}
.IP =>
-DESTROYDB(\*(xx\) \- l\o'o"'sche eine existierende Datenbank
.br
.ft B
destroydb
.ft R
[
.ft B
flags
.ft R
] dbname
.IP =>
.ft B
-destroyr
.ft R
[
.ft B
flags
.ft R
] dbname {relname}
.IP =>
-HELPR(\*(xx\) \- Information \o'u"'ber Datenbanken und Relationen
.br
.ft B
helpr
.ft R
[
.ft B
flags
.ft R
] dbname [[integrity | permit | view ]{ relname} ]
.IP =>
.ft B
-indexr
.ft R
[
.ft B
flags
.ft R
] dbname prim_rel index_rel {domname}
.IP =>
.ft B
-manr
.ft R
{sections}
.IP =>
.ft B
-modifyr
.ft R
[
.ft B
flags
.ft R
] dbname relname storage_structure
.br
.nf
         {domname [ :sortorder]}
.fi
.IP =>
-QUEL(\*(xx\) \- \*(yy\ relationales Datenbanksystem
.br
.ft B
quel
.ft R
[
.ft B
flags
.ft R
] dbname [ process_table ]
.br
.ft B
quel_dt
.ft R
.br
.ft B
quel_eng
.ft R
.IP =>
-PRINTR(\*(xx\) \- drucke Relationen
.br
.ft B
printr
.ft R
[
.ft B
flags
.ft R
] dbname { relname }
.IP =>
-PURGE(\*(xx\) \- l\o'o"'sche alle verfallenen und tempor\o'a"'ren Relationen
.br
.ft B
purge
.ft R
[
.ft B
flags
.ft R
] { dbname }
.IP =>
.ft B
-refr
.ft R
{sections}
.IP =>
-RESTORE(\*(xx\) \- Recovery nach einem \*(yy\ oder \*(xx\ crash
.br
.ft B 
restore
.ft R
[
.ft B 
flags
.ft R
] { dbname }
.IP =>
.ft B
-saver
.ft R
[
.ft B
flags
.ft R
] dbname relname month day year
.IP =>
-SYSMOD(\*(xx\) \- modifiziere die Systemrelationen zu
vordefinierten Speicherstrukturen
.br
.ft B 
sysmod
.ft R
[
.ft B 
flags
.ft R
] dbname
{
.ft B 
relname
.ft R
}
.IP =>
-USERSETUP(\*(xx\) \- erstelle \*(yy\ -Nutzerverzeichnis
.br
.ft B 
usersetup
.ft R
[-]
.IP =>
-ZIP(\*(xx\) \- erstelle Eingabeprozedur f\o'u"'r AMX- oder EQUEL-Programme
.br
.ft B 
zip
.ft R
.ft B 
[flags]
.ft R
.ft B 
mask_file
.ft R
{flags[flag_arg]}
.br
.ds RF \f3\*(xx\f1
.bp
.sp 10
.SH
.ft B
                    \*(yy\ - Referenz Manual
.ft R
.sp 5
.SH
.ft B
                           TEIL \*(xx
.ft R
.sp 5
.nf
################################################################
################################################################
##                                                            ##
##                                                            ##
##                                                            ##
##                                                            ##
##                                                            ##
##        ###   #     #  #####          ######  ######        ##
##         #    ##    # #     #         #     # #     #       ##
##         #    # #   # #               #     # #     #       ##
##         #    #  #  # #  ####         #     # ######        ##
##         #    #   # # #     #         #     # #     #       ##
##         #    #    ## #     #         #     # #     #       ##
##        ###   #     #  #####  ####### ######  ######        ##
##                                                            ##
##                                                            ##
##                                                            ##
##              #     # #     #   ###   #     #               ##
##              #     # ##    #    #     #   #                ##
##              #     # # #   #    #      # #                 ##
##              #     # #  #  #    #       #                  ##
##              #     # #   # #    #      # #                 ##
##              #     # #    ##    #     #   #                ##
##               #####  #     #   ###   #     #               ##
##                                                            ##
##                                                            ##
##                                                            ##
##                                                            ##
##                                                            ##
################################################################
################################################################
.fi
.LP
.ds RH \f3AMX\f1
.bp
.LP
.ft B 
NAME
.ft R
.IP
amx - erweitertes Zugriffsmethoden-Interface
.br
      Access Method - an eXtended Interface
.LP
.ft B 
SYNOPSIS
.ft R
.IP
.ft B 
amx
.ft R
[
.ft B
flags
.ft R
] file.x
.br
.ft B
amxf
.ft R
[
.ft B
flags
.ft R
] file.x
.br
.ft B
samx
.ft R
[
.ft B
flags
.ft R
] file.x
.br
.ft B
oamx
.ft R
[
.ft B
flags
.ft R
] file.x
.br
.ft B
oamxf
.ft R
[
.ft B
flags
.ft R
] file.x
.LP
.ft B 
BESCHREIBUNG
.ft R
.IP
Der AMX-Compiler hat prinzipiell eine \o'a"'hnliche
Aufgabe, wie der Pre-Prozessor EQC. Seine herausragende
Bedeutung beruht auf dem schnellen Zugriff der erzeugten
Programme auf die Tupel von Relationen f\o'u"'r aktive
Anwendungsf\o'a"'lle.
.IP
Dieser Vorteil wurde dadurch erreicht, dass die Zugriffsmethode
aus dem Datenbanksystem herausgel\o'o"'st und
verselbst\o'a"'ndigt in einem C-Programm l\o'a"'uft.
.IP
.ft B 
AMX
.ft R
ist in das relationale Modell von \*(yy\ 6.3/3 integriert.
Durch ein AMX-Programm k\o'o"'nnen Daten einer \*(yy\ 6.3/3
Datenbank manipuliert werden. AMX ist an die Programmiersprache C
gebunden, es erzeugt ein g\o'u"'ltiges C-Programm, das mit
dem C-Compiler weiter verarbeitet wird. Es besteht
aus einem Compiler (Preprozessor) und einer
Laufzeitbibliothek "liba.a".
Sein Vorteil besteht in der wesentlich h\o'o"'heren
Zugriffsgeschwindigkeit (gegen\o'u"'ber EQC: Faktor 0,1 bis 0,01),
sein Nachteil in der Beschr\o'a"'nkung auf
.ft B
DML
.ft R
\-Kommandos.
AMX ist die entscheidende Voraussetzung zur Erzeugung
laufzeiteffektiver Programme auf 16-bit Computern.
.IP
.ft B 
Compilation
.ft R
.IP
AMX-Programmnamen m\o'u"'ssen mit ".x" enden. Der Aufruf des
Preprozessors und der automatische Ruf des Compilers erfolgt mit
.DS I
amx -o file file.x
.DE
Es k\o'o"'nnen die, von cc bekannten Flags und
Optionen genutzt werden.
Die f\o'u"'r amx notwendigen Bibliotheken werden
automatisch eingezogen, private Bibliotheken
sind anzugeben.
.IP
.ft B 
Achtung!
.ft R
Beachten sie, dass das ausf\o'u"'hrbare Programm auf
den Modus "6711" (chmod) eingestellt und "ing_db"
angeeignet ist. Sofern Programme kopiert werden, sind
diese Eigenschaften wiederherzustellen!
.IP
.bp
.ft B 
Syntax
.ft R
.IP
AMX-Programme  laufen jetzt im  current  directory,  d.h.
file-Namen m\o'u"'ssen nicht l\o'a"'nger als volle  Pfadnamen
angegeben werden.
.br
Der AMX-Compiler hat den C-Compiler als  Untermenge
integriert,  d.h. die Benutzung von  AMX(UNIX) entspricht der
Benutzung von cc(1).
.br
Der  AMX-Compiler  kennt gegen\o'u"'ber dem  C-Compiler keine
neuen Flags, alle Flags sind also Flags von cc(1).
.br
Bei der Erzeugung von  Datenbankprogrammen muss immer der
AMX-Compiler anstelle des  C-Compilers  verwendet werden.
F\o'u"'r das Linken eines  Programmes muss das Flag `-o name'
zur  Angabe des  Programmnamens  spezifiziert werden,  um
das automatische  Laden  der  Laufzeitbibliothek des AMX-
Compilers anzuweisen.  Die  Laufzeitbibliothek muss unter
dem Namen  `.../lib/liba.a'  bereitgestellt werden,  darf
also  nach  der  Generierung nicht nach  `/usr/lib'  bzw.
`/lib' bewegt werden.
.IP
Beispiele:
.nf
.RS
.IP 1)
Erzeuge Objektmodul aus einer AMX-Quelle
    amx -c -O neuheit.x
.IP 2)
Erzeuge Programm aus einem Objektmodul
    amx -o neuheit neuheit.o
.IP 3)
Erzeuge Programm aus einer AMX-Quelle
    amx -O -o neuheit neuheit.x
.IP 4)
Erzeuge Programm aus einer AMX- und einer C-Quelle
    amx -O -o neuheit.x zusatz.c
.IP 5)
Erzeuge Objektmodule aus einer AMX- und einer C-Quelle
    amx -c -O neuheit.x zusatz.c
oder
    amx -c -O neuheit.x;cc -c -O zusatz.c
.IP 6)
Erzeuge Programm aus Objektmodulen
    amx -o neuheit neuheit.o zusatz.o
.fi
.RE
.IP
Nat\o'u"'rlich k\o'o"'nnen auch  Bibliotheken verarbeitet werden,
bzw. `neuheit.o' kann in eine Bibliothek gestellt werden.
Auf jeden Fall muss mit dem AMX-Compiler gelinkt werden !
.IP
.nf
Neben dem AMX-Statement
   ## ing_db [flags] db_name
gibt es jetzt
   ## shared [flags] db_name
wobei `ing_db' die Datenbank exklusiv (also alleinig) und
`shared' die Datenbank parallel verwendbar er\o'o"'ffnet.
.IP
Das neue AMX-Statement
   ## tuplelength rel_name c_var_name
stellt in der  numerischen  C-Variablen  `c_var_name' die
Tupell\o'a"'nge der Relation `rel_name' bereit.
Es gibt die M\o'o"'glichkeit Transaktionen  (TA) zu formulieren,
die nutzerbezogene Datenbankkonsistenzen realisierren.
Eine TA wird durch
   ## use ([+]rel_name {, [+]rel_name})
eingeleitet und durch
   ## commit
beendet.  Das Zeichen `+' gibt an,  dass die Relation
ge\o'a"'ndert werden soll (REPLACE, DELETE oder APPEND).  Fehlt
diese Angabe,  wird von der Relation gelesen  (RETRIEVE).
Folgende Regeln sollten bei der Formulierung von TA's
beachtet werden:
.fi
.br
.RS
.IP 1)
Immer `shared' verwenden, wenn nicht ausdr\o'u"'cklich die
alleinige Verwendung der Datenbank beabsichtigt ist.
.IP 2)
Immer TA's formulieren, wenn Recherchen \o'u"'ber mehr als
eine Relation gehen sollen.
.IP 3)
Alle \o'A"'nderungen in TA's einkleiden.
.IP 4)
Wenn eine  TA l\o'a"'uft,  kann keine weiter  TA  begonnen
werden.
.IP 5)
Innerhalb einer Recherche (RETRIEVE) kann keine TA
begonnen werden,  die   Recherche muss in die  TA
eingeschlossen werden.
.IP 6)
Innerhalb einer TA kann keine Recherche oder \o'A"'nderung
f\o'u"'r eine Relation,  die nicht Bestandteil der TA ist,
gestartet werden.  Die Relation muss in die  TA eingeschlossen werden.
.RE
.IP
\o'A"'hnlich EQUEL werden
AMX-Anweisungen durch die Kennzeichnung von "##" am Zeilenanfang
in das C-Programm eingebettet.
.IP
Folgende Typen von C-Variablen werden unterst\o'u"'tzt:
.DS L
     - short         (i2)
     - int           (i2)
     - long          (i4)
     - float         (f4)
     - double        (f8)
     - char *
     - char []       (c1...255)
.DE
Jede Variable ist global zu deklarieren, der Wertebereich
ist implementationsabh\o'a"'ngig (Klammerwerte beziehen sich
auf 16-Bit-Prozessoren).
.IP
In C-Programmen stehen die Typen
.DS L
    i1, i2, i4, f4 und f8

.DE
f\o'u"'r die Deklaration von Austauschvariablen zur
Verf\o'u"'gung.
.br
Alle AMX-Routinen und globale Variablen beginnen mit den
Zeichen "AA", somit sind alle Namen der Form "AA ..." reserviert
und sollten in den AMX-Programmen vermieden werden.
.IP
Im AMX-Programm muss die Eintrittsfunktion "amx()" heissen,
da der Preprozessor ein "main()" generiert. Die Datenbank
muss, einschliesslich zu verarbeitender Relationen (Struktur)
gegr\o'u"'ndet sein.
Die erste Zeile des Programms benennt die Datenbank:
.DS I
## ing_db [flags] dbname
oder
## shared [flags] dbname
.DE
Die ausf\o'u"'hrliche Beschreibung folgt im Teil II, hier
folgende Kurzform:
.IP
.nf
Bezeichnung der verwendeten Datenbank (Einzel-,
Mehrnutzer-DB):
.ft B 
"##    ing_db [flags] dbname" oder "##   quel [flags] dbname"
.ft R

.ft B 
"##    shared [flags] dbname"
.ft R

\o'O"'ffnen der Relation:
.ft B 
"##    open rel"
.ft R

Schliessen der Relation:
.ft B 
"##    close rel"
.ft R

F\o'u"'r Mehrnutzer-DB Sperrbereich zum Update der Kataloge
einstellen:
.ft B 
"##    use ([mode]rel, ..)"
.ft R

.ft B 
"##    commit"
.ft R

Anf\o'u"'gen an eine Relation:
.ft B 
"##    append rel target"
.ft R

Werte im Tupel ersetzen:
.ft B 
"##    replace target"
.ft R

Tupel l\o'o"'schen:
.ft B 
"##    delete"
.ft R

Tupel drucken:
.ft B 
"##    print ()"
.ft R

Anzahl der Tupel einer Relation bestimmen:
.ft B 
"##    tuplecount c_var"
.ft R

Tupel finden (Recherche und positionieren),
analog "retrieve" aufzufassen:
.ft B 
"##    retrieve rel qual target"
.ft R
.fi
.IP
.ft B 
Erl\o'a"'uterung:
.ft R
.DS L
flags:    +Zahl    =: Anzahl zus\o'a"'tzlicher
                      Puffer f\o'u"'r die Zugriffs-
                      methoden

          -u login =: alter-ego-Flag f\o'u"'r
                      das AMX-Programm

.DE
.DS L
rel:    Relationenname
qual:   Qualifikation =: $dom1 op $dom2, ...
                         $dom1 op c_var, ...
                         $dom1 = c_const
target: Wertzuweisung =: ($dom1=$dom2, ...)
                         (c_var=$dom1, ...)
                         ($dom1=c_var, ...)
                         $dom1 = c_const
op:     Vergleich     =: =, >, >=, <, <=, != 
c_var:  f\o'u"'r amx g\o'u"'ltige C-Variable
mode:   Lesen und Schreiben =: +
        Lesen =: (Standard, ohne Angabe)
.DE
.IP
Zur Verdeutlichung folgende Beispiele:

.DS L
    ----------------------------------------------------

    ##  ing_db dt

    amx()
    {
    /* analog: retrieve (personal.all) */
    ## open personal
    ## retrieve personal
    ## {
    ##     print ()
    ## }
    ## close personal
    }
.DE
.IP
.DS L


    ## ing_db demo

    ## i2    tnum;

    amx()
    {
    /* analog: retrieve (teile.tname, teile.tnum)
    **           where teile.tnum = 2 or teile.tnum = 10
    */
    ## open teile
    ## retrieve teile $tnum <= 10 and $tnum >= 2 (tnum = $tnum)
    ## {
          if (tnum == 2 || tnum == 10)
          {
    ##            print ($tname, $tnum)
                  putchar('\\n');
          }
    ## }
    ## close teile
    }
.DE
Die Definition im "retrieve" $tnum = 10 and $tnum = 2 w\o'u"'rde
einen Widerspruch liefern, da die logischen Ausdr\o'u"'cke nicht
mit "or" verkn\o'u"'pft werden k\o'o"'nnen.
.LP
.DS L
------------------------------------------------------
.DE

Beispiel f\o'u"'r geschachtelte "retrieve's":
.nf


## shared demo


## char		personal[21];
## int		leiter;

amx()
{
   printf("retrieve (personal.name) und den Chef von ihm\\n");
   printf("------------\\n");
## open personal

## retrieve personal (personal = $name, leiter = $leiter)
## {
        printf("personal %s ", personal);
        if (leiter == 0)
        {
        	printf("Direktor\\n");
        	continue;
        }
##	scan personal $num = $leiter (personal = $name)
##	{
        	printf("Leiter %s\\n", personal);;
##	}
## }

## close personal
   printf("------------\\n");
}
.fi

----------------------------------------------------
.LP
Die mit "printf()" realisierten Ausgaben zeigen eine
Analogie zum entsprechenden QUEL-Kommando, mit der Ausnahme,
dass anstelle der target_variable'n der Relationenname
verwendet wurde.
.LP
Beispiel f\o'u"'r einen rekursiven "retrieve" als Prozedur:
.nf


## shared demo


## i2		leiter;
## char		personal[21];

amx()
{
   printf("retrieve (personal.name) and all chefes of him\\n");
   printf("------------\\n");
## open personal

## retrieve personal (personal = $name, leiter = $leiter)
## {
        scan();
## }

## close personal
   printf("------------\\n");
}

scan()
{
   printf("%s ", personal);
   if (leiter == 0)
   {
        putchar('\\n');
        return;
   }
## retrieve personal $num = leiter 
##	(personal = $name, leiter = $leiter)
## {
        scan();
## }
}
.fi

----------------------------------------------------
.LP
Ermittlung der Tupelanzahl:
.nf


## shared demo


## i2		leiter;
## char		personal[21];

amx()
{
   register int count;
   int		c_cnt;
   int		l_cnt;
   int		p_cnt;

   printf("retrieve (personal.name) und seine Position\\n");
   printf("------------\\n");
   c_cnt = l_cnt = p_cnt = 0;
## open personal

## retrieve personal (personal = $name, leiter = $leiter)
## {
        printf("%s ", personal);
        if (leiter == 0)
        {
        	printf("chef\\n");
        	c_cnt++;
        	continue;
        }
        count = 0;
##	scan personal $leiter = $num
##	{
        	count++;
##	}
        if (count)
        {
        	printf("Leiter\\n");
        	l_cnt++;
        }
        else
        {
        	printf("Angestellter\\n");
        	p_cnt++;
        }
## }

## close personal
   printf("TOTAL:\\t%3d\\n", c_cnt + l_cnt + p_cnt);
   printf("\\t%3d Direktoren\\n", c_cnt);
   printf("\\t%3d Leiter\\n", l_cnt);
   printf("\\t%3d Angestellte\\n", p_cnt);
   printf("------------\\n");
}
.fi

----------------------------------------------------
.LP
Rekursiver "retrieve" zur Ermittlung einer Struktur:
.nf


## shared demo


   int		level;
## i2		leiter;
## char		personal[21];

amx()
{
   printf("retrieve personal structure\\n");
   printf("------------\\n");
## open personal
   leiter = 0;
   scan();
## close personal
   printf("------------\\n");
}

scan()
{
   register int		i;

   if (leiter)
   {
        for (i = level - 1; i; --i)
        	putchar('\\t');
        printf("%s\\n", personal);
   }
   level++;
## retrieve personal $leiter = leiter
##	 (personal = $name, leiter = $num)
## {
        scan();
## }
   --level;
}
.fi

----------------------------------------------------
.LP
Verwendung von "use" und "commit":
.nf

## shared demo

amx()
{
   printf("retrieve (lieferung.lnum)\\n");
   printf("where teile.tname = \\"Zentraleinheit\\"\\
         and lieferung.tnum = teile.tnum\\n");
   printf("------------\\n");
## open teile
## open lieferung

## use (teile, lieferung)
## retrieve teile $tname = "Zentraleinheit"
## {
##	retrieve lieferung $tnum = $tnum
##	{
##		print ($lnum)
##	}
## }
## commit

## close teile
## close lieferung
   printf("------------\\n");
}
.fi

----------------------------------------------------
.LP
Die folgenden Beispiele sind so gehalten, dass sie
sich ohne M\o'u"'he selbst orientieren k\o'o"'nnen.
.nf

## shared demo

amx()
{
   printf("delete personal\\n");
   printf("retrieve (personal.all)\\n");
   printf("------------\\n");
## open personal

## use (+personal)
## retrieve personal
## {
##	delete
## }
## commit

## use (personal)
## retrieve personal
## {
##	print ()
        printf("------------\\n");
## }
## commit

## close personal
   printf("------------\\n");
}


----------------------------------------------------

## shared demo

amx()
{
   printf("delete personal where personal.leiter = 129\\n");
   printf("retrieve (personal.all)\\n");
   printf("------------\\n");
## open personal

## use (+personal)
## retrieve personal $leiter = 129
## {
##	delete
## }
## commit

## use (personal)
## retrieve personal
## {
##	print ()
        printf("------------\\n");
## }
## commit

## close personal
   printf("------------\\n");
}


----------------------------------------------------

## shared demo

amx()
{
   printf("append personal (name = \\"Heinrich, Heinz\\",\\
         gehalt = 10000)\\n");
   printf("retrieve (personal.name, personal.gehalt)\\n");
   printf("------------\\n");
## open personal

## use (+personal)
## append personal ($name = "Heinrich, Heinz",
##	 $gehalt = 10000)
## commit

## use (personal)
## retrieve personal
## {
##	print ($name, $gehalt)
## }
## commit

## close personal
   printf("------------\\n");
}


----------------------------------------------------
.fi
.IP
.ft B 
Deklarationen
.ft R
.IP
C-Variable, die zwischen den Dom\o'a"'nen und dem C-Programm
Werte \o'u"'bergeben oder \o'u"'bernehmen sollen, m\o'u"'ssen
global deklariert werden und durch "##" amx bekannt
gemacht werden. Die Deklaration muss vor amx() stehen und
das Zeilenende mit ";" abgeschlossen werden.
Die Anzahl dieser Variablen ist begrenzt (unabh\o'a"'ngig vom Typ: 255).
.IP
.ft B 
"Fehler und Unterbrechungen"
.ft R
.IP
.ft B 
\o'U"'bersetzungsfehler
.ft R
werden in folgender Form ausgegeben:
.DS I
Zeilennummer: Fehlertext
.DE
\o'U"'bersetzungsfehler f\o'u"'hren nicht zum Abbruch
der \o'U"'bersetzung.
Fehler sind selbsterkl\o'a"'rend.
Syntaktische Fehler werden durch die Ausschrift
.DS L
    syntax error
.DE
ohne n\o'a"'here Erl\o'a"'uterung ausgewiesen.
Aufgrund der einfachen Syntax von AMX muss der Fehler
selbst gedeutet werden.
.br
Angaben von Zeilennummern beziehen sich sowohl
vom AMX-Compiler als auch vom C-Compiler auf die
AMX-Quelle.
.RE
.IP
Neben den \o'U"'bersetzungsfehlern werden vom AMX Compiler bzw.
dem \*(yy\ 6.3/3 System Fehler erzeugt, die zum Abbruch der
\o'U"'bersetzung fuehren.
.IP
.ft B
Laufzeitfehler
.ft R
.IP
AMX Laufzeitfehler werden durch die Ausgabe von mehrzeiligen
Meldungen protokolliert. Nach einem Fehler wird das AMX
Programm mit dem exit-Wert 1 beendet. Alle
Fehlernummern < 100 verweisen auf interne Fehler des Datenbanksystems
\*(yy\ 6.3/3 und  sollten von einem \*(yy\ 6.3/3
Systemprogrammierer analysiert werden. Auf jeden Fall sollte die
Konsistenz der Datenbank \o'u"'berprueft werden (siehe
(RESTORE(\*(xx\)). Alle Fehlernummern >= 100 sind
Nutzerfehler, die vom Anwendungsprogrammierer selbst
analysiert werden k\o'o"'nnen.
.IP
In der ersten Zeile wird die Nummer des aufgetretenen
Fehlers ausgewiesen:
.DS I
AMXERR: * * * * * * *   VALUE
.DE
.IP
Ist die C-Variable "errno" ungleich 0, wird anschliessend
der \*(xx\-Fehlerwert (siehe \*(xx\-Manual INTRO(2))
protokolliert:
.DS I
UNIX   error   VALUE
.DE
.IP
Dieser Wert muss nicht unbedingt mit dem aufgetretenen
Fehler zusammenh\o'a"'ngen, da die C-Variable "errno" vor einem
\*(xx\-Ruf nicht auf 0 gesetzt wird und auf einen, im Programm
weit zur\o'u"'ckliegenden Fehler verweisen kann.
.IP
Hat die Zugriffsmethode einen Fehler erzeugt, wird er in
folgender Form protokolliert:
.DS I
ACCESS  error   VALUE
.DE
.IP
Die Werte VALUE haben folgende Bedeutung:
.DS L
-1   read error
-2   write error
-3   open error
-4   open error of system catalog "relation"
-5   open error of system catalog "attribute"
-6   missing or too many domains for a relation
-7   close error
-8   unknown storage structure
-9   invalid tupel identifier (tid)
-10  attempt to open a view
.DE
.IP
Der folgende AMX Rueckkehrwert
.DS I
AMX-RCVALUE
.DE
.IP
verweist auf Inkonsistenzen in der Datenbasis und  muss  von
einem \*(yy\ 6.3/3 Systemprogrammierer ausgewertet werden.
.IP
Zuletzt wird die oben genannte Fehlernummer durch einen Text
n\o'a"'her erl\o'a"'utert.
.RE
.LP
.ds RH \f3COPYDB\f1
.ds LH Referenz-Manual
.bp
.RE
.ft B 
NAME
.ft R
.IP
copydb -
erzeuge Quellprogramme, um Relationen einer
Datenbank zu sichern bzw. neu zu erstellen
.RE
.sp 1
.ft B 
SYNOPSIS
.ft R
.IP
.ft B 
copydb
.ft R
[
.ft B 
flags
.ft R
] dbname directory { relname }
.RE
.sp 1
.ft B 
BESCHREIBUNG
.ft R
.IP
copydb
erzeugt zwei QUEL-Programme im angegebenen
.ft B 
directory:
.ft R
.RS
.IP copy.out 10
enth\o'a"'lt QUEL-Statements zum
.ft B 
Kopieren
.ft R
von Relationen der mit
.ft B 
dbname
.ft R
bezeichneten Datenbank auf
.ft B 
(copy-into)
.ft R
\*(xx\-Files innerhalb des angegebenen
.ft B 
directory.
.ft R
Es erfolgt eine Auswahl der Relationen:
Grunds\o'a"'tzlich werden nur solche Relationen
ko\%piert, f\o'u"'r die der Nutzer Eigner ist.
Es werden davon alle Relationen angesprochen,
wenn nicht im Kommando mit
{relname}
eine konkrete
Aufz\o'a"'hlung
erfolgt.
.IP copy.in 10
enth\o'a"'lt QUEL-Statements, mit denen die
eben ausgew\o'a"'hlten Relationen erzeugt werden,
die R\o'u"'ck-Kopien
.ft B 
(from)
.ft R
erfolgen, ggf. Indizes erzeugt werden
und auch ggf. Modifizierungen
.ft B 
(modify)
.ft R
der erzeugten Relationen erfolgen.
Alle Zugriffsberechtigungen, Integrit\o'a"'ten und
Sichten wurden definiert.
.RE
.IP
Die Programme sind damit dazu
verwendbar, eine Menge von Relationen
in Files eines directory zu speichern
und aus diesen auf einer leeren Datenbank
wieder deren alten Zustand
herstellen zu k\o'o"'nnen.
Ausserdem liefert das Programm die Dokumentation zur 
Struktur der Relation.
.IP
Die erzeugten Files erhalten den gleichen Namen,
wie die der Relationen:
der dem Nutzer bekannte
.ft B 
relname
.ft R
gefolgt vom \*(yy\ 6.3/3-Usercode (2 Bytes).
Das 
.ft B 
directory
.ft R
muss mit vollem Pfadnamen angegeben werden.
Der Pfad darf nicht dem Datenbankpfad entsprechen.
Das ist insbesondere zu beachten, wenn die Datenbank
ausserhalb des Standards angelegt ist.
.RE
.sp 1
.ft B 
BEISPIEL
.ft R
.DS
cd /mnt/meindir
copydb db backup
quel db < backup/copy.out
tar r1 backup
rm -r backup

tar x1
quel db < backup/copy.in
.DE
.RE
.sp 1
.ft B 
SIEHE AUCH
.ft R
.IP
quel(unix),
copy(quel),
create(quel),
index(quel),
modify(quel),
define(quel),
integrity(quel),
view(quel),
permit(quel)
.RE
.sp 1
.ft B 
HILFEN
.ft R
.IP
.ft B 
copydb
.ft R
erzeugt in copy.in QUEL-Statements zur Modifizierung von Relationen
und Indizes auf die Speicherstruktur, die sie vorher hatten.
Allerdings werden dabei weder fillfactor-
noch minpage-/maxpage-Spezifikationen erzeugt.
.IP
Bei Sichten und Zugriffsrechten k\o'o"'nnen Probleme 
entstehen, wenn die Sichten oder Zugrifsrechte nutzerfremde 
Relationen einschliessen und diese zum Zeitpunkt der 
Abarbeitung des 
.ft B
copy_in
.ft R
\-Programms noch nicht existieren.
.IP
Zu einer sich daraus notwendig ergebenden
oder sonst\%wie gew\o'u"'nschten Anpassung
k\o'o"'nnen die Kommandofiles editiert werden.
.RE
.ds RH \f3COPYR\f1
.bp
.RE
.ft B
NAME
.ft R
.IP
copyr - Kopieren von Daten einer Relation von \/ auf
ein \*(xx\-Standart-File
.LP
.ft B
SYNOPSIS
.ft R
.IP
.ft B
copyr
.ft R
[
.ft B
flags
.ft R
]dbname relname {domname format}
.ft B
into|from
.ft R
file
.LP
.ft B
BESCHREIBUNG
.ft R
.IP
.ft B
copyr
.ft R
transportiert die Daten zwischen einer \*(yy\-Relation
und einem \*(xx\-Standard\-File.
Ein Tupel der Relation mit seinen Dom\o'a"'nen
wird einem Satz der Datei mit seinen Feldern zugeordnet.
Die Transportrichtung
.ft B
<direction>
.ft R
ist entweder
.ft B
into
.ft R
oder
.ft B
from.
.ft R
Die mit
.ft B
<relname>
.ft R
bezeichnete Relation muss jedenfalls existieren.
Die <domname>'s m\o'u"'ssen
Dom\o'a"'nen dieser Relation sein.
Das ihnen zugeordnete Format
.ft B
<fformat>
.ft R
ist das der Felder des \*(xx\-File.
Das \*(xx\-File muss mit
"Filename"
durch einen kompletten Pfadnamen
(auf der Wurzel, also mit "/" beginnend)
angegeben werden.
.IP
Beim Kopieren in die Relation
(
.ft B
copyr
.ft R
<relname>
(...)
.ft B
from
.ft R
"Filename"
)
wird das Statement nur vom Eigent\o'u"'mer der Relation angenommen.
Die Relation darf keine Systemrelation oder
kein Sekund\o'a"'rindex sein
und keinen Sekund\o'a"'rindex haben.
.IP
Beim Kopieren in das \*(xx\-File (
.ft B
copyr
.ft R
<relname>
(...)
.ft B
into
.ft R
"Filename"
) wird das Statement nur vom Eigent\o'u"'mer der Relation angenommen
oder von einem Nutzer, der f\o'u"'r sie
Zugriffsberechtigung
.ft B
retrieve
.ft R
hat.
Der Nutzer muss die entsprechende Berechtigung
f\o'u"'r das file_directory haben.
Das \*(xx\-File wird mit file_mode 0600
angelegt oder falls es schon vorhanden
ist, neu erzeugt.
Der
.ft B
copyr
.ft R
verwendende Nutzer wird Eigent\o'u"'mer des \*(xx\-File.
.IP
Beim Kopieren werden folgende Formate
.ft B
<fformat>
.ft R
f\o'u"'r die Felder des \*(xx\-File
unterst\o'u"'tzt:
.IP
.RS
.IP
.ft B
i1, i2, i4
.ft R
 1\-, 2\- oder 4\-Byte\-Integer
.IP
.ft B
f4, f8    
.ft R
 4\- oder 8\-Byte Gleitkomma
(einfache oder doppelte Genauigkeit)
.IP
.ft B
c1, c2, ... c255
.ft R
 \- Zeichenkette fester angegebener L\o'a"'nge
.IP
.ft B
c0[<delim>] | "c0<delim>"
.ft R
\- Zeichenkette variabler L\o'a"'nge
beendet durch den Begrenzer \c
.ft B
<delim>
.ft R
(delimitor)
.IP
.ft B
d0[<delim>] | "d0<delim>"
.ft R
.br
.ft B
d1 ... d255
.ft R
.br
\- ein f\o'u"'r die Relation bedeutungsloses
Feld (dummy-Feld siehe folgend).
.RE
.IP
Die L\o'a"'ngenangaben in
.ft B
<fformat>
.ft R
d\o'u"'rfen f\o'u"'hrende Nullen haben.
.IP
Die im Statement zugeordnete Dom\o'a"'ne der Relation
zum Feld des File m\o'u"'ssen nicht vom selben Typ
oder derselben L\o'a"'nge sein,
.ft B
copyr
.ft R
f\o'u"'hrt die notwendigen Konvertierungen durch
(s. aber unten Laufzeitfehler).
.IP
Im Statement m\o'u"'ssen die Dom\o'a"'nen der Relation
in der Reihenfolge der Felder der S\o'a"'tze des \*(xx\-File
aufgez\o'a"'hlt werden.
Die Zuordnung in der Relation erfolgt per Spaltennamen.
Nicht aufgez\o'a"'hlte Dom\o'a"'nen der Relation
bleiben vom Kopieren ausgeschlossen
(bei
.ft B
from
.ft R
werden sie durch 0 bzw. eine Leerkette "" initia\%lisiert).
Der Satz des \*(xx\-File muss vollst\o'a"'ndig
beschrieben werden.
Vom Kopieren ausgeschlossene Felder m\o'u"'ssen
als
.ft B
dummy\c
.ft R
\-Felder aufgez\o'a"'hlt werden.
Der f\o'u"'r die dummy\-Felder im Statement
angegebene
.ft B
<domname>
.ft R
ist f\o'u"'r die Relation bedeutungslos.
.IP
.ft B
copyr
.ft R
unterst\o'u"'tzt die Arbeit mit variabel langen Feldern
auf dem \*(xx\-File, f\o'u"'r die das, sie hinten
begrenzende Zeichen, als Begrenzer (delimitor)
.ft B
<delim>
.ft R
bestimmt werden muss.
Da die \o'u"'blicherweise gew\o'a"'hlten Begrenzer
auch innerhalb der QUEL eine syntaktische Bedeutung haben,
k\o'o"'nnen solche Zeichen symbolisch angegeben werden:
.RE
.DS I
Bezeichner
  f\o'u"'r        bezeichnet
.ft B
<delim>
.ft R
-------------------------------------------------
nl           new_line-Zeichen <nl>
tab          Tabulator-Zeichen <tab>
sp           (space) <blank>-Zeichen
nul          "\e0" Byte vom Wert 0
null         "\e0" Byte vom Wert 0
comma        Komma ","
colon        Semikolon ";"
dash         Bindestrich "-"
lparen       (left  parenthesis) "("
rparen       (right parenthesis) ")"
x            ein beliebiges Zeichen `x'
"x"          ein beliebiges Zeichen `x'
.DE
.RE
.IP
Man kann das
.ft B
<fformat>
.ft R
auch als
.ft B
"c0<delim>"
.ft R
bzw.
.ft B
"d0<delim>
.ft R
schreiben,
um eine Spezialbedeutung von <delim>
innerhalb von QUEL aufzuheben.
.IP
Bei der Arbeit mit variablen Feldern
sind Besonderheiten abh\o'a"'ngig von der Transportrichtung
zu beachten.
.IP
In die Relation:
.br
.ft B
copyr
.ft R
.ft B
relname
.ft R
(...)
.ft B
from
.ft R
"Filename" :
.RS
.IP
Wenn
.ft B
<delim>
.ft R
im Statement bei
.ft B
c0
.ft R
oder
.ft B
d0
.ft R
nicht angegeben ist,
wird das erste auftretende
Komma, <tab> oder <nl>
als Feldbegrenzer gewertet,
sonst begrenzt das angegebene Zeichen <delim>
das Feld.
Das Begrenzerzeichen wird nicht in das Attribut \o'u"'bernommen.
Enth\o'a"'lt das Feld das Begrenzerzeichen an Stellen, wo
es noch nicht Begrenzer sein soll,
ist diesem Zeichen im Feld ein <backslash> ( "\e" )
voranzustellen.

Beispiele:
.DS I
chardom= c0     Zeichenkette endend
                auf Komma, <tab> oder <nl>
chardom= c0nl   dto endend auf <nl>
chardom= "c0#"  dto endend auf #

.DE
Wenn chardom= c0comma definiert ist,
w\o'u"'rde der Feld\%inhalt
.br
	Neumann\e, Karl,
.br
den Attributwert
.br
	Neumann, Karl
.br
erzeugen.
.IP
Es wird empfohlen, bei der Anlage von \*(xx\-Files,
die zur Kopie auf \*(yy\-Relationen vorgesehen sind,
einen Satzbegrenzer einzuf\o'u"'hren,
der sich von allen Feldbegrenzern unterscheidet.
Dadurch wird
.ft B
copyr
.ft R
synchro\%nisiert,
auch wenn ein Satz f\o'a"'lschlicherweise
nicht die richtige Anzahl von Feldern hat.
.RE
.IP
In das File:
.br
.ft B
copyr
.ft R
relname (...)
.ft B
into
.ft R
"Filename" :
.IP
c0	
.br
.RS
.IP
Das Attribut wird in eine Zeichenkette fester L\o'a"'nge
umgewandelt, diese wird in das File geschrieben.
F\o'u"'r die Attribute von Zeichenketten\-Dom\o'a"'nen
ergibt sich die L\o'a"'nge aus dem Dom\o'a"'nen-Format
.ft B
<format>
.ft R
selbst, f\o'u"'r Attribute
numerischer Dom\o'a"'nen erfolgt eine ascii\-Umwandlung
auf das Druckformat, das bei Sitzungsstart
durch die \*(yy\-Optionen
.ft B
-i,
.ft R
.ft B
-f,
.ft R
oder
.ft B
-c
.ft R
beeinflusst werden kann (s.
.ft B
quel\c
.ft R
(unix)).
.RE
.IP
c0<delim>	
.br
.RS
.IP
wie c0, zus\o'a"'tzlich wird das Zeichen <delim>
in das Feld geschrieben.
.RE
.bp
.IP
d0	
.br
.RS
.IP
unzul\o'a"'ssig
.RE
.IP
d0<delim>	
.br
.RS
.IP
Das Zeichen <delim> wird einmal in den Satz des File
geschrieben;
der im Statement angegebene <domname> ist bedeutungslos.
.RE
.IP
d1, d2, ... d255	
.br
.RS
.IP
Der <domname> muss einer der oben als "Bezeichner f\o'u"'r <delim>"
aufgez\o'a"'hlten sein.
Das von ihm bezeichnete Zeichen wird 1,2, ... 255 mal
in den Satz des \*(xx\-File geschrieben.
.RE
.IP
d1<delim>, d2<delim>, ... d255<delim>	
.br
.RS
.IP
Das Zeichen <delim> wird 1,2, ...255 mal
in das \*(xx\-File geschrieben.
Der im Statement angegebene <domname>
ist bedeutungslos.
.RE
.RE
.IP
Zur Sicherung und Wiederherstellung
einzelner Relationen kann das Statement in der Kurzform:
.IP
.RS
.IP
.ft B
copy
.ft R
relname ()
direction
"Filename"
.RE
.IP
verwendet werden physiche Kopie = (bulk_copy).
Das Statement wird in diesem Falle automatisch mit allen
Dom\o'a"'nen der Relation in deren Erzeugungsreihenfolge
und deren Formaten erg\o'a"'nzt.
Man spart Formulierungsaufwand, die Abarbeitung
erfolgt schneller als f\o'u"'r andere
.ft B
copyr\c
.ft R
\-Statements, da Konvertierungen entfallen.
.IP
Ein
.ft B
copyr into
.ft R
\-Kommando wird auf Relationen mit Indizes nicht
unterst\o'u"'tzt.
.IP
.ft B
File:
.ft R
.nf
   UNIX-file-Name, als voller Pfadname oder # f\o'u"'r
   Standardinput bei COPY ... FROM "#" bzw.
   Standardoutput bei COPY ... INTO "#".
.fi
.IP
.ft B
Flags:
.ft R
.nf
   -uxx        - alter-ego-Flag f\o'u"'r
                 den UNIX-login-Name `xx'
   +-w         - wait-Flag
.fi
.RE
.ds RH \f3CREATDB\f1
.bp
.ft B 
NAME
.ft R
.IP
creatdb \- Erzeuge eine Datenbank
.RE
.sp 1
.ft B 
SYNOPSIS
.ft R
.IP
.ft B 
creatdb
.ft R
[
.ft B 
flags
.ft R
] [
.ft B 
\-e
.ft R
] [
.ft B 
\-m
.ft R
] [
.ft B 
+-c
.ft R
] [
.ft B 
+-q
.ft R
] dbname
.RE
.sp 1
.ft B 
BESCHREIBUNG
.ft R
.IP
.ft B 
creatdb
.ft R
erzeugt eine neue \*(yy\ Datenbank
oder modifiziert den Status einer existierenden.
Der das Kommando verwendende Nutzer wird der
Datenbankadministrator (DBA) f\o'u"'r die Datenbank.
Der DBA hat spezielle Berechtigungen,
die den normalen Nutzern versagt werden.
Die Benutzung des Kommandos setzt die Erlaubnis
zur Erzeugung von Datenbanken (siehe
.ft B 
users
.ft R
(files)) voraus.
.IP
.ft B 
dbname
.ft R
ist der Name der zu erzeugenden Datenbank.
Der Name muss einmalig (unique)
unter allen Datenbanknamen aller
\*(yy\ 6.3/3 Nutzer sein.
.IP
Es gibt jetzt die M\o'o"'glichkeit, die Seitengr\o'o"'sse der
Datenbank an das  Betriebssystem  anzupassen.  Unterst\o'u"'tzt
werden  Seitengr\o'o"'ssen von 512 und 1024 Bytes.  Durch die
Angabe des Flags `-1' werden  512'er und durch die Angabe
es Flags `-2' werden 1024'er Datenbanken erzeugt.
.br
Standard sind 1024'er Datenbanken.
.br
Beide  Formen k\o'o"'nnen  parallel in einem  System angelegt
werden, \*(vv\ verwaltet diesen Unterschied intern.
512'er k\o'o"'nnen nicht in 1024'er  Datenbanken  konvertiert
werden,  dazu m\o'u"'ssen sie  logisch  auskopiert und wieder
einkopiert werden (siehe copydb(unix)).
.IP
Das Flag
.ft B 
+-c
.ft R
definiert die Gleichzeitigkeitskontrolle der Datenbank.
Die Form
.ft B 
+c
.ft R
schaltet sie ein (shared database = Standardannahme) und
.ft B 
-c
.ft R
aus (private database).
.IP
Die Gleichzeitigkeitskontrolle sollte
nicht ausgeschaltet werden,
es sei denn f\o'u"'r Datenbanken,
die nie von mehr als einem Nutzer benutzt werden.
Sie muss auch eingeschaltet werden,
wenn die Nutzer keine gemeinsamen (shared)
Datenrelationen haben,
da die Systemkataloge immer parallel verwendet werden!
Wenn die Gleichzeitigkeitskontrolle 
nicht in \*(xx\ installiert ist,
das \*(xx\-Spezialfile ``/dev/ing_lock'' nicht existiert
oder nicht schreibbar f\o'u"'r \*(yy\ 6.3/3 ist,
dann wird die Gleichzeitigkeitskontrolle
nicht wirksam (als wenn sie ausgeschaltet ist).
.IP
Die Gleichheitskontrolle f\o'u"'r
eine existierende Datenbank
kann durch die Angabe des
.ft B 
\-e
.ft R
Flags ver\o'a"'ndert werden.
Zum Beispiel:
.RS
.IP
creatdb \-e +c meine_db
.RE
.IP
schaltet die Gleichzeitigkeitskontrolle (c: concurrency control)
f\o'u"'r die Datenbank ``meine_db'' ein.
Nur der DBA der Datenbank darf das
.ft B 
\-e
.ft R
(existing) Flag verwenden.
.IP
Das
.ft B 
\-m
.ft R
(mounted) Flag besagt,
dass das \*(xx\ directory bereits existiert,
in dem die Datenbank angelegt werden soll.
Das kann f\o'u"'r sehr grosse Datenbanken n\o'u"'tzlich sein,
die als Filesystem montiert (mounted) werden m\o'u"'ssen.
Das directory muss existieren,
es kann durch folgende Kommandofolge angelegt werden:
.IP
Das Anlegen wird an einem Beispiel erkl\o'a"'rt.
.IP
.nf
1) creatdb mount_db
2) destroydb -m mount_db
HINWEIS: Jetzt vom  \*(xx\-Superuser einen Datentraeger
         in  `.../data/base/mount_db' mounten lassen.
3) creatdb -m [weiter Flags moeglich] mount_db
   In der  Zukunft muss immer darauf  geachtet werden,  dass
   wenn die  Datenbank  mount_db  angesprochen  werden soll,
   auch der Datentr\o'a"'ger gemountet ist !
.br
.IP
Datenbanken k\o'o"'nnen auch ausserhalb des 
Systemstandards angelegt werden. Dazu ist notwendig:
.RS
.IP (1)
Das entfernte DB-directory anzulegen
.IP (2)
Die Datenbank mittels 
.ft B
creatdb
.ft R
erzeugen
.IP (3)
Die Files der Datenbank aus dem Standard-directory
../data/base/<dbname> in das entfernte directory
kopieren
.IP (4)
Die Files und das directory der Datenbank im 
Standard-directory l\o'o"'schen.
.IP (5)
Das File ../data/base/<dbname> mit dem Modus 600
(Eigent\o'u"'mer ing_db) erzeugen.
Das File muss den Pfadnamen des entfernten
DB-directory (Einzeiler) enthalten.
.RE
.RE
.IP
Die zuk\o'u"'nftige Verwendung bedingt keine 
besonderen Angaben zur Lage der Datenbank.
Das 
.ft B 
\+-q
.ft R
\-Flag dient der Ein- bzw. Ausschaltung des QRYMOD-Komplexes.
Bei existierenden Datenbanken kann der QRYMOD-Komplex
nicht wieder ausgeschaltet werden.
.br
F\o'u"'r die Verwendung des define(quel)-Statements
ist die Generierung des QRYMOD-Komplexes (+q)
unerl\o'a"'sslich.
.RE
.LP
.ft B
BEISPIEL
.ft R
.IP
creatdb demo
.br
creatdb \-uerichs \-c erichs_db
.br
creatdb -e +c erichs_db
.IP
Das Erstellen der Datenbank erichs_db auf einem separaten 
Datentr\o'a"'ger:
.RS
.IP -
vom Systemadministrator ausf\o'u"'hren lassen:
.DS L
     mkdir .../data/base/erichs_db
     chmod 777 .../data/base/erichs_db
.DE
.IP -
vom \*(xx\-Superuser ausf\o'u"'hren lassen:
.DS L
     Montieren des Ger\o'a"'tes auf das directory
     .../data/base/erichs_db
.DE
.IP -
selbst ausf\o'u"'hren:
.DS L
     creatdb -m erichs_db
.DE
.RE
.RE
.IP
Es muss jetzt daf\o'u"'r gesorgt werden, dass vor jeder 
Verwendung der Datenbank erichs_db das Filesystem montiert 
werden muss.
.IP
Erstellen der Datenbank erichs_db im entfernten 
directory /tmp/erich/db
.RS
.IP -
selbst aussf\o'u"'hren:
.DS L
    mkdir /tmp/erich/db
    chmod 777 /tmp/erich/db
.DE
.IP -
vom ing_db-Superuser ausf\o'u"'hren lassen:
.DS L
    creatdb erichs_db
    mv .../data/base/erichs_db/*  /tmp/erich/db
    rmdir .../data/base/erichs_db
    echo /tmp/erich/db > .../data/base/erichs_db
    chmod 600 .../data/base/erichs_db
.DE
.RE
.RE
.sp 1
.ft B 
SIEHE AUCH
.ft R
.IP
destroydb(unix),
users(files)
.RE
.ds RH \f3CREATER\f1
.bp
.RE
.ft B
NAME
.ft R
.IP
creater - Erzeugen einer neuen Relation
.LP
.ft B
SYNOPSIS
.ft R
.IP
.ft B
creater
.ft R
[
.ft B
flags
.ft R
] dbname relname {dom format}
.LP
.ft B
BESCHREIBUNG
.ft R
.IP
.ft B
creater
.ft R
erzeugt eine neue Relation in der aufliegenden Datenbank.
Die Relation wird dem, das Statement ausl\o'o"'senden
Nutzer, zugeeignet (dieser ist ihr "Eigent\o'u"'mer")
und f\o'u"'r 7 Tage reserviert.
Wenn dieser Nutzer der DBA ist,
wird die Relation zur allgemeinen Benutzung (shared),
andernfalls nur f\o'u"'r den Nutzer pers\o'o"'nlich (private)
verf\o'u"'gbar.
Der Name der erzeugten Relation ist
.ft B
<relname>, 
.ft R
ihre Dom\o'a"'nen werden mit den aufgef\o'u"'hrten
.ft B
<domname>
.ft R
\'s angelegt und erhalten die, jeweils f\o'u"'r sie
spezifizierten Formate (s.
.ft B
quel:
.ft R
<format>).
.IP
Die Relation wird als heap ohne Daten initialisiert.
F\o'u"'r andere Nutzer werden keine Zugriffsrechte 
eingetragen.
.IP
Eine Relation kann implementierungsabh\o'a"'ngig 49
bzw. 128 Dom\o'a"'nen bekommen.
Die Namen der System-Relationen
(relation, attribute, indexes, tree, protect, integrities, references)
sind reservierte Relationen\-Namen.
.IP
Die vom Anwender gew\o'a"'hlten Namen m\o'u"'ssen
den \*(yy\-Konventionen gen\o'u"'gen.
Namen d\o'u"'rfen kleine Buchstaben, Ziffern
und das Unterstreichungszeichen "_" enthalten;
m\o'u"'ssen mit einem Buchstaben oder "_" anfangen
und d\o'u"'rfen maximal 12 Zeichen lang sein).
Schl\o'u"'sselworte von QUEL oder AMX sollten vermieden werden.
.IP
Attributnamen sind lokale Namen innerhalb einer
Relation und m\o'u"'ssen hier eindeutig sein.
Relationennamen werden von \*(yy\ mit einem
Codenamen des, sie erzeugenden Nutzers erg\o'a"'nzt.
Ein Nutzer greift dadurch bei gleichen
Relationennamen innerhalb einer Datenbank
immer auf "seine" Relation zu.
.IP
Die maximale Satzl\o'a"'nge ist generierungsabh\o'a"'ngig
und betr\o'a"'gt 498 bzw. 1010 Bytes.
.IP
.ft B
Format:
.ft R
.DS L
    i1, i2, i4 - 1, 2 bzw. 4-Byte-Integer
    f4, f8     - Gleikommazahl  (einfache, doppelte Genauigkeit)
    c1 .. c255 - Zeichenkette fester L\o'a"'nge
.DE
Flags:
.DS L
     -uxx       - alter-ego-Flag f\o'u"'r
                  den UNIX-login-Name `xx'
     +-w        - wait-Flag
.DE
.RE
.ds RH \f3DESTROYDB\f1
.bp
.RE
.ft B 
NAME
.ft R
.IP
destroydb \- L\o'o"'sche eine existierende Datenbank
.RE
.sp 1
.ft B 
SYNOPSIS
.ft R
.IP
.ft B 
destroydb
.ft R
[
.ft B 
flags
.ft R
] [
.ft B 
\-m
.ft R
] dbname
.RE
.sp 1
.ft B 
BESCHREIBUNG
.ft R
.IP
.ft B 
destroydb
.ft R
l\o'o"'scht alle Bez\o'u"'ge zu einer existierenden Datenbank.
Das directory der Datenbank und alle Files (Relationen)
in diesem directory werden gel\o'o"'scht.
.IP
Das Kommando kann nur der Datenbankadministrator (DBA)
oder der \*(yy\ Superuser
bei Angabe des
.ft B 
\-s
.ft R
Flags ausf\o'u"'hren.
.IP
Bei entfernt angelegten Datenbanken wird das Verweisfile zur 
Datenbank und das entfernt liegende directory gel\o'o"'scht.
.IP
Das
.ft B 
\-m
.ft R
Flag weist
.ft B 
destroydb
.ft R
an, das
\*(xx\ directory
der Datenbank nicht zu l\o'o"'schen.
Das kann n\o'u"'tzlich sein,
wenn die Daten der Datenbank auf einem separaten
(m = mounted)
\*(xx\-Filesystem sind.
.RE
.sp 1
.ft B 
BEISPIEL
.ft R
.IP
destroydb demo
.br
destroydb \-s erichs_db
.RE
.sp 1
.ft B 
FILES
.ft R
.IP
\&.../data/base/*
.LP
.ft B 
SIEHE AUCH
.ft R
.IP
creatdb(unix)
.RE
.ds RH \f3DESTROYR\f1
.bp
.RE
.ft B
NAME
.ft R
.IP
destroyr - L\o'o"'schen von Relationen
.LP
.ft B
SYNOPSIS
.ft R
.IP
.ft B
destroyr
.ft R
[
.ft B
flags
.ft R
] dbname {relname}
.LP
.ft B
BESCHREIBUNG
.ft R
.IP
.ft B
destroyr
.ft R
streicht Relationen aus der aufliegenden Datenbank.
Das Kommando wird nur vom Eigent\o'u"'mer der Relation(en)
angenommen.
Will man von einer Relation nur deren Inhalt
\- also alle Tupel \- streichen,
aber die Defi\%nition der Relation erhalten ,
benutzt man das
.ft B
delete
.ft R
\-Statement ohne where-Phrase
oder das
.ft B
modify
.ft R
\-Statement mit der Speicherstruktur
.ft B
truncated.
.ft R
.IP
Beim Streichen einer Relation,
f\o'u"'r die Sekund\o'a"'rindizes definiert sind,
werden automatisch auch diese gestrichen.
Das Streichen eines Sekund\o'a"'rindex selbst
hat auf dessen Prim\o'a"'r-Relation keine Auswirkung.
.IP
Das
.ft B
"destroy permit"
.ft R
\-Statement l\o'o"'scht gegebene 
Zugriffsrechte zu der Relation "relname", das 
"destroy-integrity"-Statement definierte Integrit\o'a"'ten.
.br
Das Schl\o'u"'sselwort
.ft B
"all"
.ft R
gibt an, dass alle 
Zugriffsrechte bzw. Integrit\o'a"'ten gestrichen werden sollen.
Um einzelne Zugriffsrechte bzw. Integrit\o'a"'ten zu l\o'o"'schen,
muss eine, durch Komma getrennte constraint-Liste (Nummern) 
angegeben werden. Die constraint's erh\o'a"'lt man durch 
.ft B
help permit
.ft R
bzw.
.ft B
help integrity.
.ft R
.IP
.ft B
Flags:
.ft R
.IP
.DS L
   -uxx    alter-ego-Flag f\o'u"'r den
           UNIX-login-Name `xx'
   +-w     wait-Flag
.DE
.RE
.ds RH \f3EQC\f1
.bp
.ft B 
NAME
.ft R
.IP
eqc \- Compiler f\o'u"'r die
.br
         in C eingebettete QUEL-Schnittstelle EQUEL
.RE
.sp 1
.ft B 
SYNOPSIS
.ft R
.IP
.ft B 
eqc 
.ft R
[
.ft B 
\-d
.ft R
] [
.ft B 
\-f
.ft R
] [
.ft B 
\-r
.ft R
] file1.q [filen.q]
.RE
.sp 1
.ft B 
BESCHREIBUNG
.ft R
.IP
EQUEL (Embedded QUEL) ist eine Sprache zur Einbettung von
Datenbankanfragen in eine Programmiersprache.
Als Anfragesprache wird QUEL verwendet.
.IP
EQUEL besteht aus der EQUEL-Laufzeitbibliothek, die die 
Schnittstelle zur Datenbank realisiert (call- Interface),
und einem Compiler zur \o'U"'bersetzung eines Programms 
mit eingebetteten EQUEL-Statements in g\o'u"'ltige 
Anweisungen der Programmiersprache.
.br
Das 
.ft B
call
.ft R
\-Interface ist f\o'u"'r alle Programmiersprachen 
verf\o'u"'gbar, ein Compiler existiert zur Zeit 
nur f\o'u"'r die Programmiersprache C.
.IP
.ft B 
Compilation
.ft R
.IP
Der Pre-Compiler wird durch das Kommando:
.RS
.IP
.ft B 
eqc 
.ft R
{flags} file1.q {flags} file2.q ...
.RE
.IP
aufgerufen, wobei
.ft B 
filen.q
.ft R
die Quelleingabe-Files sind,
deren Namen mit
.ft B 
\&.q
.ft R
beendet sein m\o'u"'ssen.
Die Ausgabe wird auf das File
.ft B
`filen.c'
.ft R
geschrieben.
Es k\o'o"'nnen so viele Files wie gew\o'u"'nscht spezifiziert werden.
.br 
Folgende Flags k\o'o"'nnen gesetzt werden:
.br
.RS
.IP -d
Generiert Code zum Quelltext des Files mit Name
und Zeilennummer, die bei auftretenden Laufzeit-Fehlern angezeigt
werden. Das ist zum Analysieren der Fehler n\o'u"'tzlich,
ben\o'o"'tigt aber mehr Platz.
Standard ist "aus".
.IP -f
Erzeugt Code, bei dem "Output"- und "Input"-Files
gew\o'o"'hnlich die gleiche Zeilennummer haben,
um die C-\Diagnose-\Mitteilungen leichter
interpretieren zu k\o'o"'nnen. Manchmal muss EQUEL versuchen,
Queries in mehrere Zeilen zu zerlegen, um einen
Zeilen\o'u"'berlauf des C-Preprozessors zu vermeiden.
Dann transportiert es C-Code einige Zeilen nach vorn.
Mit der -f Flagspezifikation passiert das nicht.
C-Code steht in der richtigen Zeile und Reihenfolge.
Entsprechend kann die Zeile des Quellcodes mit der
Zeile der C-Diagnose referenzieren.
.IP -r
Setzt Flags auf Standardwerte zur\o'u"'ck. Das wird verwendet,
um andere Flags f\o'u"'r Files aus der Argumentliste
zu unterdr\o'u"'cken.
.RE
.IP
Die Ausgabe-Files k\o'o"'nnen dann mittels des C-Compilers
\o'u"'bersetzt werden:
.RS
.IP
.ft B 
cc
.ft R
file1.c file2.c ... 
.ft B 
\-lq
.ft R
.RE
.IP
Die Schreibweise
.ft B 
\-lq
.ft R
fordert die
EQUEL-Laufzeit-Bibliothek an.
Die Bibliothek 
.ft B 
libq.a
.ft R
muss zur Angabe der Option -lq auf
.ft B 
/lib/libq.a
.ft R
oder
.ft B 
/usr/lib/libq.a
.ft R
stehen, d.h. sie muss bei der Installation von
/.../ing_db/lib/libq.a dorthin kopiert werden.
.IP
Alle
EQUEL-\c
Routinen und globalen Variablen beginnen mit den Zeichen "II",
somit sind alle Namen von Prozeduren und Variablen der Form
II\c
.ft B 
xxx
.ft R
reserviert f\o'u"'r die Nutzung durch
EQUEL
und sollten von
EQUEL-\c
Nutzern vermieden werden.
.IP
.ft B 
Syntax
.ft R
.IP
EQUEL
Kommandos sind solche Zeilen, die mit zwei Nummernzeichen
(``##'') eingeleitet sind.
Alle anderen Zeilen werden einfach von der Ein- zur
Ausgabe kopiert.
Alle normalen
\*(yy\ 6.3/3 -\c 
Kommandos k\o'o"'nnen in
EQUEL
benutzt werden und haben die gleiche Bedeutung, wie
unter dem interaktiven Terminal\-Monitor.
Nur das retrieve-Kommando ohne Ergebnisrelation hat eine
andere Syntax und Bedeutung.
.IP
Das Format des retrieve ohne Ergebnisrelation ist jetzt:
.RS
.IP
## retrieve (C-var = a_fcn { , C-var = a_fcn } )
.RE
.IP
wahlweise (sofort) gefolgt durch:
.RS
.IP
##	[
.ft B 
where
.ft R 
"<qual>"
]
.br
## {
.br
        /* C-Code */
.br
## } 
.RE
.IP
Dieses Statement bewirkt, dass der ``C-code''
f\o'u"'r jedes gefundene Tupel mit den aktuellen Werten der
``C-Variablen'' einmal abgearbeitet wird.
Die Angabe ``##{'' bzw. ``##}''
ist auch dann notwendig,
wenn nach dem Tupel-Retrieve
nur ein einziges C-Statement abgearbeitet werden soll.
Numerische Werte numerischer Typen werden, wenn n\o'o"'tig,
konvertiert. Zwischen numerischen und Zeichenkettenwerten
werden keine Konvertierungen ausgef\o'u"'hrt.
(Die normale QUEL-\c
.ft B 
ascii
.ft R
-Funktion kann f\o'u"'r solche Zwecke verwendet werden.)
Das C-Statement ``break'' ist die einzige M\o'o"'glichkeit,
ein laufendes Tupel-Retrieve vorzeitig zu beenden.
Die Qualifikation <qual> der where-Phrase
kann in allen QUEL-Statements durch eine
C-String-Variable (char qual[n] bzw. char *qual)
ersetzt werden.
Der String enth\o'a"'lt den Text der Qualifikation,
d.h. es ist eine variable Angabe der Qualifikation
in einem EQUEL-Statement zul\o'a"'ssig.
.IP
Beim copy-Statement kann die Angabe
der direction (INTO bzw. FROM) \o'u"'ber eine
C-String-Variable erfolgen.
Die C-Variable muss zur Zeit der Abarbeitung
des EQUEL-Statements "from" bzw. "into" enthalten.
Zus\o'a"'tzlich sind folgende
EQUEL-\c
Kommandos verf\o'u"'gbar.
.IP
.sp
.ft B 
"## ing_db"
.ft R
[ing_db flags] <data_base_name>
.RS
.IP
Dieses Kommando startet
\*(yy\ 6.3/3
und dirigiert alle folgenden Queries an die Datenbank
.ft B 
<data_base_name>.
.ft R
Die zweimalige Ausf\o'u"'hrung des Kommandos ohne ein
dazwischenliegendes
``## exit''
erzeugt einen Laufzeitfehler,
ebenso das Formulieren von Queries, ohne dass ein
``##\ ing_db'' Statement wirksam ist.
Jedes Flag sollte gequotet werden, um den
EQUEL  Parser nicht zu verwirren:
.IP
        ## ing_db "\-f4f10.2" "\-i212" demo
.RE
.IP
.ft B 
"## exit"
.ft R
.RS
.IP
Exit beendet ein laufendes
\*(yy\ 6.3/3.
Es ist \o'a"'quivalent zu dem
.ft B 
\eq
.ft R
Kommando des Terminal\-Monitors.
.RE
.IP
Innerhalb von EQUEL-Statements sind
C Kommentare
.br
``/* comment */'' zul\o'a"'ssig.
.IP
.ft B 
"Parametrisierte QUEL-Statements"
.ft R
.IP
QUEL-Statements mit Zielliste (<target_list>) k\o'o"'nnen
parametrisiert sein. Das kann durch Voranstellen des
Schl\o'u"'sselworts 
.ft B 
param
.ft R
angezeigt werden. Die Zielliste eines parametrisierten
Statements hat die Form:
.RS
.IP
.ft B 
"(tl_var, argv)"
.ft R
.RE
.IP
Dabei wird
.ft B 
tl_var
.ft R
als char-Pointer verwendet, der zur Ausf\o'u"'hrungszeit
(muss char-Konstante sein !) wie folgt interpretiert
wird. F\o'u"'r jedes parametrisierte EQUEL-Statement, ausser
dem "retrieve" ohne Ergebnisrelation
(d.h. append, copy, create, replace, retrieve into) wird
die Zeichenkette
.ft B 
tl_var
.ft R
als regul\o'a"'re Zielliste verwendet, wobei davon ausgegangen
wird, dass dem "%" ein g\o'u"'ltiger \*(yy\ 6.3/3-Typ
(f4, f8, i2, i4, c) folgt. Jedes "%" wird durch den Wert
des korrespondierenden Eintrittspunktes in 
.ft B 
argv
.ft R
(beginnend mit 0) ersetzt, welcher als Pointer auf eine Variable
des Typs, der durch die %-Sequenz angezeigt ist,
interpretiert wird.
Weder 
.ft B 
argv
.ft R
, noch die Variablen, auf die gezeigt wird, m\o'u"'ssen
f\o'u"'r EQUEL deklariert werden. Zum Beispiel:
.DS L

double    double_var;
int       int_var;
char *argv[10];
     argv[0] = &double_var;
     argv[1] = &int_var;
## param append to rel
##      ("dom1=%f8, dom2=%i2", argv)
## /* Zur Steuerung des "%<ing_db_typ"-Mechanismus */
## /* verwende "%%",                               */
## /* dies plaziert ein einfaches "%" in die       */
## /* Zeichenkette.                                */
.DE
.IP
Bei einem "retrieve" auf C-Variablen mittels
.ft B 
tl_var
.ft R
, steuern die selben "%"-Sequenzen die Typ-Kennzeichnung
des korrespondierenden "argv"-Punktes der C-Variablen,
in welche der Wert \o'u"'bergeben werden soll.
.IP
Die Qualifikation einer Query kann durch eine
char-Variable, deren Inhalt zur Laufzeit als Text
zur Qua\%lifikation interpretiert wird, \o'u"'bergeben werden.
.IP
Das
.ft B 
copy
.ft R
-Statement kann auch parametrisiert werden. Die Form der Parameter
ist analog den anderen Statements:
.br
Die Zielliste kann in der selben Art und Weise,
wie beim
.ft B 
append
.ft R
-Statement und dar\o'u"'berhinaus f\o'u"'r das "from/into"-\c
Schl\o'u"'sselwort durch einen Zeichenkettenwert, der zur
Laufzeit <from> oder <into> beinhalten muss,
ersetzt werden.
.IP
.ft B 
Deklarationen
.ft R
.IP
Jede g\o'u"'ltige C-Variablendeklaration einer Zeile,
die mit ``\c
.ft B 
##\c
.ft R
\'\'
beginnt, kann in einem
EQUEL
Statement als Variable benutzt werden.
Alle Variablen m\o'u"'ssen vor ihrer Verwendung
deklariert werden.
\o'U"'berall, wo eine Konstante in einem
\*(yy\ 6.3/3 
Kommando stehen darf,
kann eine C-Variable erscheinen.
Zur Laufzeit wird der Wert der Variablen substituiert.
.IP
Es gibt einige Einschr\o'a"'nkungen f\o'u"'r die C-Variablen,
die in EQUEL Statements verwendet werden sollen.
.IP
Weder geschachtelte Strukturen noch Variable
vom Typ
.ft B 
char
.ft R
(ausgenommen Pointer auf char oder char-Felder)
sind zugelassen.
Alle von EQUEL erzeugten strings
sind damit auch strings im Sinne von C
und z.B. direkt mittels ``printf'' druckbar.
In einem
EQUEL 
Statement wird zur Laufzeit immer auf den Wert einer
Variablen zugriffen.
Zum Beispiel:
.DS L
##	char	*dbname;

        /* ing_db -d dt */
        dbname = "dt";
##	ing_db "-d" dbname

        /* ing_db -d dbname */
##	ing_db "-d" #dbname
.DE
.IP
bewirkt die Verwendung der Datenbank
``dt'' durch
\*(yy\ 6.3/3.
Weiterhin gibt es zwei Einschr\o'a"'nkungen zur Referenz
von Variablen mit EQUEL-Statements.
Alle verwendeten Variablen d\o'u"'rfen nicht auf weitere verweisen
(bei Feldern und Pointern) oder weitere
(bei Struktur-Variablen) im Sinne von skalaren Werten ausw\o'a"'hlen.
.ft B 
char
.ft R
\-Variablen werden immer im Sinne von Zeichenketten
.ft B 
(strings)
.ft R
durch EQUEL
verwendet.
Dabei muss beachtet werden,
dass bei char-Feldern oder -Pointern der Verweis nur durch ein
``char *'' erfolgen darf.
Genauso d\o'u"'rfen Variable keine (runden) Klammern in
der Referenz haben. Zum Beispiel:
.DS L

## struct xxx
## {
        int	i;
##	int	*ip;
## }	**struct_var;

/* nicht erlaubt */
##	delete p where p.ifield = *(*struct_var)->ip

/* erlaubt */
##	delete p where p.ifield = *struct_var[0]->ip
.DE
.IP
C-Variablen, die f\o'u"'r EQUEL deklariert wurden, haben
entweder globale oder lokale G\o'u"'ltigkeit. Ihre G\o'u"'ltigkeit
ist lokal, wenn sie in einem (nicht f\o'u"'r retrieve eingebunden)
freien Block f\o'u"'r EQUEL deklariert sind.
Zum Beispiel:
.DS L
/* globale Variable */
## int	Gint;

func(i)
int	i;
## {
        /* lokale Variable */
##	int	*gintp;
        ...
## }
.DE
.IP
Wenn eine Variable vom char-Typ ist, wird der Inhalt der
Variablen vom EQUEL-Statement zur Laufzeit genutzt.
Zum Beispiel:
.DS L
##	char	*dbname[MAXDATABASES + 1];
        int	current_db;

        dbname[current_db] = "dt";
##	ing_db dbname[current_db]
.DE
Damit wird versucht, die Datenbank "dt" zu starten.
Jedoch sollte, wenn der Variablen-Name eine Konstante ist,
der Nicht-Referenz-Operator `#' verwendet werden (s.o.).
.IP
F\o'u"'r die Verwendung der C-Preprozessor `# include '-Einbindung
f\o'u"'r Files, die EQUEL-Statements und Deklarationen enthalten,
soll die Bezeichnung 
.ft B 
anything.q.h
.ft R
verwendet werden.
Eine entsprechende EQUEL-Beearbeitung erzeugt dann das File,
das durch den C-Preprozessor # include'ed wird, in Form
von 
.ft B 
anything.c.h\c
.ft R
 .
.IP
.sp 2
.ft B 
Fehler und Unterbrechungen
.ft R
.IP
\*(yy\ 6.3/3 
und 
EQUEL 
Laufzeitfehler rufen die Routine
.ft B 
IIerror
.ft R
mit der Fehlernummer und den Parametern des Fehlers,
als Feld von Stringpointern (analog zu der C-main-Routine).
Die Fehlernummer wird analysiert und anschliessend der
dazugeh\o'o"'rige Text gedruckt.
.IP
Unterbrechungen
.ft B 
(interrupt
.ft R
oder
.ft B 
quit-signal)
.ft R
werden behandelt
.ft B 
(caught),
.ft R
sofern sie nicht schon zur Startzeit von
\*(yy\ 6.3/3 
ignoriert sind.
Damit ist gesichert, dass
\*(yy\ 6.3/3 
und
EQUEL 
jederzeit synchron zueinander sind.
Es gibt einen Pointer auf eine Funktion
.ft B 
"IIinterrupt,"
.ft R
die nach der Behandlung der Unterbrechung aufgerufen wird.
Der Nutzer kann mit dieser Funktion noch zus\o'a"'tzliche
Dienste f\o'u"'r die Unterbrechungsbehandlung einbinden.
.ft B 
IIinterrupt
.ft R
ist mit
.ft B
"exit()"
.ft R
initialisiert und wird mit
-1
als Argument gerufen.
Zum Beispiel:
.DS L
        extern int (*IIinterrupt)();
        extern IIreset();

        IIsetexit();
        IIinterrupt = IIreset;
        mainloop();
.DE
.IP
IIsetexit und IIreset entsprechen setjmp und longjmp
(\*(xx\ Manuals III).
Um Unterbrechungen zu ignorieren, sollte
.ft B 
"signal()"
.ft R
gerufen werden, bevor das
## ing_db Statement ausgef\o'u"'hrt wird.
.RE
.sp 1
.ft B 
FILES
.ft R
.IP
 ...sys/etc/error6.3_*
.br
Kann zur Erkl\o'a"'rung der
\*(yy\ 6.3/3 Errorcodes
durch den Nutzer herangezogen werden.
.IP
 .../lib/libq.a
.br
Laufzeitbibliothek (run time library).
.RE
.sp 1
.ft B 
SIEHE AUCH
.ft R
.IP
EQUEL-Sprachbeschreibung, 
.br
C-Sprachbeschreibung,
.br
Anwendungsbeispiele zu EQUEL im Teil 3
.RE
.ds RH \f3HELPR\f1
.bp
.RE
.ft B 
NAME
.ft R
.IP
helpr
- Ausgabe von Informationen \o'u"'ber
Relationen in Datenbanken
.RE
.sp 1
.ft B 
SYNOPSIS
.ft R
.IP
.ft B 
helpr
.ft R
.ft B 
[flags]
.ft R
dbname [ [integrity|permit|view] {relname} |
.ft B
all
.ft R
]
.RE
.sp 1
.ft B 
BESCHREIBUNG
.ft R
.IP
.ft B 
helpr
.ft R
informiert \o'u"'ber Relationen analog wie das
QUEL-Statement help (s. help(quel)).
Mit 
.ft B 
helpr
.ft R
k\o'o"'nnen keine Abschnitte des Referenz-Manual
ausgelistet werden, daf\o'u"'r gibt es die Kommandos 
.ft B
manr
.ft R
und
.ft B
refr.
.ft R
.IP
Mit den Parametern werden die Relationen bestimmt,
\o'u"'ber die informiert wird:
.RS
.DS L
helpr dbname     alle Relationen der bezeichneten
                 Datenbank werden ausgelistet
helpr dbname { relname }
                 Beschreibung der bezeichneten
                 Relationen
helpr dbname view relname {, relname }
                 druckt die view-Definitionen der 
                 spezifizierten view
helpr dbname permit relname {, relname}
                 druckt die Berechtigungen der 
                 spezifizierten Relationen
helpr dbname integrity relname {, relname}
                 druckt die Integrit\o'a"'ts-
                 bedingungen f\o'u"'r die
                 spezifizierten Relationen.
.DE
.RE
.IP
Diese Mengen von Relationen werden eingeschr\o'a"'nkt
in Abh\o'a"'ngigkeit vom Status des Nutzers:
.RS
.IP DBA=>
alle Relationen
.IP sonstige=>
Relationen, f\o'u"'r die spezielle Zugriffsrechte 
.ft B
retrieve
.ft R
oder
.ft B
all to all
.ft R
gesetzt sind
.RE
.IP
Das Kommando 
.ft B
helpr dbname all
.ft R
listet alle eigenen Relationen auf.
.RE
.sp 1
.ft B 
SIEHE AUCH
.ft R
.IP
quel(unix),
help(quel),
manr(unix),
refr(unix)
.RE
.ds RH \f3INDEXR\f1
.bp
.RE
.ft B
NAME
.ft R
.IP
indexr - Erzeugen einer Sekund\o'a"'rindex auf
         eine existierende Relation
.LP
.ft B
SYNOPSIS
.ft R
.IP
.ft B
indexr
.ft R
[
.ft B
flags
.ft R
] dbname prim_rel index_rel {domname}
.LP
.ft B
BESCHREIBUNG
.ft R
.IP
.ft B
indexr
.ft R
wird benutzt, um Sekund\o'a"'rindizes auf existierenden
Relationen zu definieren und zu erzeugen und damit die Effizienz
von
.ft B
retrieve
.ft R
\- und
.ft B
update
.ft R
\-Statements zu erh\o'o"'hen.
Ein Sekund\o'a"'rindex vermittelt mit seinem
Schl\o'u"'ssel einen weiteren Zugriffspfad
auf der Prim\o'a"'r\-Relation, so als
h\o'a"'tte die Prim\o'a"'r\-Relation
einen weiteren Schl\o'u"'ssel, auf den direkt zugegriffen
werden kann.
Der Sekund\o'a"'rindex wird aus den Dom\o'a"'nen der Prim\o'a"'r\-Relation
erzeugt, die in der Reihenfolge,
wie sie im Statement als
.ft B
{<domname>}
.ft R
angegeben sind, als Schl\o'u"'ssel des Index verwendet werden.
Das Statement wird nur vom Eigent\o'u"'mer der Relation
angenommen.
.IP
Um die Integrit\o'a"'t des Index zu erhalten,
kann ein Nutzer Indizes nicht direkt ver\o'a"'ndern.
Sobald die Prim\o'a"'r-Relation ge\o'a"'ndert wird,
werden auch alle auf ihr definierten
Sekund\o'a"'rindizes automatisch ver\o'a"'ndert.
.IP
Ein Sekund\o'a"'rindex wird bei seiner Erzeugung
automatisch in der Speicherstruktur isam
\o'u"'ber seinem Schl\o'u"'ssel
angelegt.
Diese Initialstruktur kann durch die QUEL\-Option
.ft B
\-n
.ft R
auf eine andere festgelegt werden (s.
.ft B
quel
.ft R
(unix)).
Ausserdem kann jeder Sekund\o'a"'rindex
einzeln durch Anwendung eines
.ft B
modifyr\c
.ft R
-Statements auf eine Speicherstruktur
gebracht werden, die anwendungsspezifisch
die beste ist.
In diesem Falle verwendet man
.ft B
<indexname>
.ft R
wie einen normalen <relname>.
.IP
Nach einem
.ft B
modifyr
.ft R
\- oder
.ft B
destroyr
.ft R
\-Kommando auf einer Prim\o'a"'r\-Relation
sind alle auf ihr definierten Sekund\o'a"'rindizes
gestrichen.
.IP
Sekund\o'a"'rindizes k\o'o"'nnen nicht auf
Systemkataloge, Sichten und
Sekund\o'a"'rindizes definiert werden.
.IP
Die  Anzahl  der   Dom\o'a"'nen  f\o'u"'r  einen  Index  ist  auf  6
beschr\o'a"'nkt.
.br
Indizes  k\o'o"'nnen nicht direkt  ge\o'a"'ndert werden,  sie werden
vom System automatisch gepflegt.
.br
Die  Speicherstruktur der  Indexrelation ist standardm\o'a"'ssig
.ft B
isam
.ft R
in der  Reihenfolge der  angegebenen  Dom\o'a"'nen.
.br
Ein
.ft B
modifyr
.ft R
\-  bzw.
.ft B
destroyr
.ft R
\-Kommando  auf die  Basisrelation
`prim_rel' zerst\o'o"'rt automatisch den Index `index_rel'.
.br
Ein
.ft B
copy into
.ft R
\-Kommando wird auf Relationen mit Indizes nicht
unterst\o'u"'tzt.
.IP
.ft B
Flags
.ft R
.DS L
   -uxx         alter-ego-Flag f\o'u"'r
                den UNIX-login-Name `xx'
   +-w          wait-Flag
   -fillfactor: zahl
   -minpages:   zahl
   -maxpages:   zahl
   -nspeicher_struktur
   -tidp    
.DE
.LP
.ft B
SIEHE AUCH
.ft R
.IP
destroyr(unix),
.RE
.ds RH \f3MANR\f1
.bp
.RE
.ft B
NAME
.ft R
.IP
manr - Anzeige einer l\o'a"'ngeren Dokumentation zu \*(yy
.LP
.ft B
SYNOPSIS
.ft R
.IP
.ft B
manr
.ft R
{sections}
.LP
.ft B
BESCHREIBUNG
.ft R
.IP
.ft B
manr
.ft R
zeigt ohne die Angabe von Parametern eine
\o'U"'bersicht \o'u"'ber die zur Verf\o'u"'gung
stehenden Sektionen.
.IP
Es werden die Kommandos der Teile
.ft B
\*(xx\
.ft R
und
.ft B
QUEL
.ft R
und Beschreibungen zu ausgew\o'a"'hlten
Files in .../sys/etc
angezeigt.
.IP
Bei der Angabe von Sektionen
wird eine l\o'a"'ngere Dokumentation des
entsprechenden Kommandos bzw. der Files angezeigt.
.LP
.ft B
BEISPIEL
.ft R
.IP
manr printr
.IP
(zeigt die Dokumentation des Kommandos "printr(unix)".
.LP
.ft B
SIEHE AUCH
.ft R
.IP
man(quel), ref(quel, refr(unix)
.RE
.ds RH \f3MODIFYR\f1
.bp
.RE
.ft B
NAME
.ft R
.IP
modifyr - \o'A"'nderung der Speicherstruktur einer Relation
.LP
.ft B
SYNOPSIS
.ft R
.IP
.ft B
modifyr
.ft R
[
.ft B
flags
.ft R
] dbname relname storage_structure {domname[:sortorder]}
.LP
.ft B
BESCHREIBUNG
.ft R
.IP
.ft B
modify
.ft R
ver\o'a"'ndert die Speicherstruktur der spezifizierten
Relation
.ft B
<relname>
.ft R
auf
.ft B
<storage_structur>.
.ft R
Das Statement wird nur vom Eigent\o'u"'mer der Relation
angenommen.
Die Systemrelationen und Sichten k\o'o"'nnen mit
.ft B
modify
.ft R
nicht modifiziert werden.
Das Statement wird benutzt,
um Prim\o'a"'rschl\o'u"'ssel einzuf\o'u"'hren, 
zu \o'a"'ndern bzw. zu reorganisieren.
Die Speicherstruktur
.ft B
<storage_structure>
.ft R
kann wie folgt bestimmt werden:
.IP
.DS L
     isam       - index sequentielle Struktur
     cisam      - komprimierte isam
     hash       - hash Struktur
     chash      - komprimierte hash
     heap       - unstrukturiert und ohne Schl\o'u"'ssel
     cheap      - komprimierte heap
     heapsort   - heap mit sortierten Tupeln
                  und Ausschluss doppelter
     cheapsort  - komprimierte heapsort
     truncated  - heap, in dem alle Tupel gestrichen
                  wurden
     same       - Reorganisation
.DE
.IP
Die Speicherstrukturen isam und hash erm\o'o"'glichen
Schl\o'u"'sselzugriffe.
Isam ben\o'o"'tigt mindestens zwei Plattenzugriffe,
unterst\o'u"'tzt aber auch sequentielle Zugriffe,
wie sie bei von-bis-Abfragen n\o'o"'tig sind.
Hash greift direkt zu, ist aber bei
sequentieller Suche uneffektiv.
Beide Verfahren ordnen neue Tupel zun\o'a"'chst
auf einer Prim\o'a"'rseite ein
und legen, wenn diese voll ist,
dahinter \o'U"'berlaufseiten an.
Bei der Suche nach einem Tupel
f\o'u"'hrt der Direktzugriff auf die Prim\o'a"'rseite,
diese und alle an ihr "h\o'a"'ngenden" \o'U"'berlaufseiten
m\o'u"'ssen nach dem Tupel abgesucht werden.
.IP
Heap ist ein v\o'o"'llig ungeordneter Bestand,
der nur sequentiell durchsucht werden kann.
Heapsort liegt nach
.ft B
modify
.ft R
in einer definierten Sortierfolge vor.
Sowohl bei heap, als auch bei heapsort
werden neue Tupel unsortiert angef\o'u"'gt.
.IP
Bei Anlage einer heapsort-Struktur
werden die Tupel nach allen ihren Attributen sortiert.
Dadurch k\o'o"'nnen und werden doppelte Tupel
ermittelt und ausgeschlossen.
Bei den Speicherstrukturen heapsort bzw. cheapsort 
kann durch die Schl\o'u"'sselw\o'o"'rter 
"ascending" bzw. "a" auf\%steigende und durch die 
Schl\o'u"'sselw\o'o"'rter "descending" bzw. "d"
fallende Sortierung angegeben werden.
.br
"ascending" ist Standard und kann demzufolge entfallen.
.IP
Bei den komprimierten Speicherstrukturen wird eine 
g\o'u"'nstigere Ablage der Daten auf dem externen 
Speichermedium erreicht, mit der Einschr\o'a"'nkung, dass
\o'A"'nderungen zeitaufwendiger sind.
.IP
Wenn im Statement die
.ft B
on
.ft R
-Phrase fehlt,
wird bei der Modifizierung auf isam, cisam, hash oder chash
als Schl\o'u"'ssel f\o'u"'r die Relation automatisch
die erste Dom\o'a"'ne verwendet.
Bei Modifizierung auf heap, cheap oder same
darf die 
.ft B
on
.ft R
-Phrase nicht angegeben werden.
Bei Modifizierung auf heapsort oder cheapsort
ist die Angabe der
.ft B
on
.ft R
-Phrase notwendig.
.IP
Wenn eine Relation sortiert werden soll
(isam, cisam, hash, chash, heapsort und cheapsort),
sind die Prim\o'a"'rschl\o'u"'ssel der Relation in der
.ft B
on
.ft R
-Phrase in der Reihenfolge der gew\o'u"'nschten
Sortierung anzugeben,
der erstangegebene bildet den dominanten
Sortierbegriff.
Die in der
.ft B
on
.ft R
-Phrase nicht angegebenen Dom\o'a"'nen werden
danach in der erzeugten Reihenfolge
zur Sortierung herangezogen.
.IP
Bei einer Modifikation zur Speicherstruktur "same" wird
die Relation reorganisiert, d.h., die Speicherstruktur, der 
Sortierschl\o'u"'ssel und deren Reihenfolge bleiben erhalten.
Nach umfangreichen \o'A"'nderungen kann die externe
Anordnung der Daten uneffektiv werden, so dass eine 
Neueinrichtung bzw. Reorganisation der Schl\o'u"'sselstruktur
sinnvoll ist.
.br
(Schl\o'u"'sselbaumstruktur !)
.IP
Ein F\o'u"'llfaktor
.ft B
<fillfactor> 
.ft R
spezifiziert die prozentuale F\o'u"'llung (1 ... 100)
der Prim\o'a"'rseiten (unter idealen Bedingungen)
bei Anlage der Relation durch das
.ft B
modify
.ft R
-Statement.
Dieser F\o'u"'llfaktor kann bei Modifizierung
auf isam, cisam, hash und chash angegeben werden.
Man vermeide die Angabe eines zu grossen
F\o'u"'llfaktors bei noch unfertigen Relationen.
Eine ungleichm\o'a"'ssige Verteilung des Schl\o'u"'ssels
kann bei folgenden Erweiterungen der Relation
zur Anlage von vielen \o'U"'berlaufseiten
f\o'u"'hren, wodurch sich das Zugriffsverhalten
der Relation sehr verschlechtert.
.IP
Bei Modifizierung auf hash oder chash spezifizieren
.ft B
minpage
.ft R
und
.ft B
maxpage
.ft R
die minimale und maximale Anzahl von Prim\o'a"'rseiten,
die die Relation haben soll.
Falls angegeben,
m\o'u"'ssen beide mindestens 1 sein;
.ft B
maxpage
.ft R
darf nicht kleiner als
.ft B
minpage
.ft R
sein.
.IP
Wenn nicht angegeben, werden folgende
Standardwerte eingesetzt:
.RE
.DS L
             FILLFACTOR      MINPAGES        MAXPAGES
             ----------      --------        --------
     hash    50              10              nach Bedarf
     chash   75              1               nach Bedarf
     isam    80              --              --
     cisam   100             --              --
.DE
.IP
Fehlt  die  Schl\o'u"'sselangabe,  wird  die  erste  Dom\o'a"'ne der
Relation der Schl\o'u"'ssel.
.br
Die Sortierung der Tupel erfolgt in der Reihenfolge der
angegebenen Dom\o'a"'nen `dom'.
.IP
.ft B
sortorder
.ft R
(Sortierungsart, nur f\o'u"'r [c]heapsort):
.nf
     a
     ascending  - aufsteigend (Standard)
     d
     descending - absteigend
.fi
.IP
.ft B
Flags
.ft R
.DS L
   -uxx       - alter-ego-Flag f\o'u"'r
                den UNIX-login-Name `xx'
   +-w        - wait-Flag
.DE
.RE
