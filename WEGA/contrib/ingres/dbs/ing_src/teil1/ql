.ds RH \f3Uebersicht\f1
.ds LH Referenz_Manual
.ds RF \f3QUEL\f1
.ds CH - % -
.bp
.NH 3
.ft B
\o'U"'bersicht der Anfrage-Kommandos *
.ft R
.LP
.IP
.RS
.IP =>
APPEND \- f\o'u"'ge neue Tupel in die Relation ein
.br
.ft B
append 
.ft R
[\c
.ft B
to\c
.ft R
] relname (target_list) [\c
.ft B
where 
.ft R
qual\c
]
.IP =>
COPY \- kopiere Daten zwischen einer Relation und einem \*(xx\ File.
.br
.ft B
copy
.ft R
relname 
([domname = fformat {, domname = fformat }])
.br
.RS
.IP
into | from "Filename"
.RE
.IP =>
CREATE \- erzeuge eine neue Relation
.br
.ft B
create
.ft R
relname (domname
= format {, domname
= format })
.IP =>
DEFINE \- definiere Subschema
.br
.ft B
define
.ft R
.ft B
view
.ft R
relname (target list) [ 
.ft B
where
.ft R
qual ]
.br
.ft B
define
.ft R
.ft B
permit
.ft R
oplist
.ft B
on
.ft R
var [ (attlist) ]
.br
.ft B
to
.ft R
name [
.ft B
at
.ft R
term ] [
.ft B
from
.ft R
time 
.ft B
to
.ft R
time ] [
.ft B
on
.ft R
day 
.ft B
to
.ft R
day ] [
.ft B
where
.ft R
qual ]
.br
.ft B
define
.ft R
.ft B
integrity
.ft R
.ft B
on
.ft R
var
.ft B
is
.ft R
qual
.IP =>
DELETE \- l\o'o"'sche Tupel aus einer Relation
.br
.ft B
delete
.ft R
var
[\c
.ft B
where
.ft R
qual\c
]
.IP =>
DESTROY \- l\o'o"'sche existierende Relationen
.br
.ft B
destroy 
.ft R
relname {, relname}
.br
.ft B
destroy
.ft R
.ft B
permit | integrity
.ft R
relname
.ft B
all |
.ft R
constraint {, constraint}
.IP =>
HELP \- liefere Hilfen \o'u"'ber \*(yy\-Nutzung
oder Informationen \o'u"'ber Relationen in der Datenbank
.br
.ft B
help 
.ft R
[\c
relname\c
{\c
,relname\c
}] 
.br
.ft B
help
.ft R
"" | "section" {,"section"}
.br
.ft B
help integrity | permit | view
.ft R
relname {,relname}
.IP =>
INDEX \- erzeuge einen Sekund\o'a"'rindex \o'u"'ber
eine existierende Relation.
.br
.ft B
index on
.ft R
relname 
.ft B
is
.ft R
indexname 
(domname
{ ,domname
})
.IP =>
INTEGRITY \- definiere Integrit\o'a"'tsbedingungen
.br 
.ft B
define integrity on
.ft R
var
.ft B
is
.ft R
qual
.IP =>
MODIFY \- modifiziere die Speicherstruktur einer Relation
.br
.RS
.IP
.ft B
modify 
.ft R
relname 
.ft B
to 
.ft R
storage-structure
.br
[
.ft B
on 
.ft R
key [ :sortorder]
{ , key :sortorder
} ] 
.br
[
.ft B
where 
.ft R
[
.ft B
fillfactor =
.ft R
n ] [
.ft B
, minpages =
.ft R
n ]
.br
[
.ft B
, maxpages =
.ft R
n ] ]
.RE
.IP =>
PERMIT \- f\o'u"'ge Berechtigungen zu einer Relation hinzu
.br
.ft B
define permit
.ft R
oplist
.ft B
on
.ft R
var [ (attlist) ]
.br
.ft B
to
.ft R
name [
.ft B
at
.ft R
term ] [
.ft B
from
.ft R
time
.ft B
to
.ft R
time ] [
.ft B
on
.ft R
day
.ft B
to
.ft R
day ] [
.ft B
where
.ft R
qual ]
.IP =>
PRINT \- drucke Relationen
.br
.ft B
print 
.ft R
relname {, relname}
.IP =>
RANGE \- deklariere eine Variable \o'u"'ber eine Relation
.br
.ft B
range
.ft R
[[
.ft B
of
.ft R
] var
.ft B
is
.ft R
relname]
.IP =>
REPLACE \- ersetze Werte von Dom\o'a"'nen in einer Relation
.br
.ft B
replace
.ft R
var (target_list)
[\c
.ft B
where
.ft R
qual]
.IP =>
RETRIEVE \- suche Tupel
.br
.ft B
retrieve 
.ft R
[[\c
.ft B
into\c
.ft R
] relname
.ft B
unique\c
.ft R
] (target_list)
[\c
.ft B
where
.ft R
qual]
.IP =>
SAVE \- sichere eine Relation bis zu einem be\%stimmten Datum
.br
.ft B
save
.ft R
relname 
.ft B
until
.ft R
month day year
.IP =>
VIEW \- definiere eine virtuelle Relation
.br
.ft B
define view
.ft R
relname (target list) [
.ft B
where
.ft R
qual ]
.RE
.bp
.SH
.ft B
                 \*(yy\ - Referenz Manual
.ft R
.sp 5
.SH
.ft B
                        TEIL QUEL
.ft R
.sp 5
.nf
################################################################
################################################################
##                                                            ##
##                                                            ##
##                                                            ##
##                                                            ##
##                                                            ##
##       ###   #     #  #####          ######  ######         ##
##        #    ##    # #     #         #     # #     #        ##
##        #    # #   # #               #     # #     #        ##
##        #    #  #  # #  ####         #     # ######         ##
##        #    #   # # #     #         #     # #     #        ##
##        #    #    ## #     #         #     # #     #        ##
##       ###   #     #  #####  ####### ######  ######         ##
##                                                            ##
##                                                            ##
##                                                            ##
##                #####  #     # ####### #                    ##
##               #     # #     # #       #                    ##
##               #     # #     # #       #                    ##
##               #     # #     # #####   #                    ##
##               #   # # #     # #       #                    ##
##               #    #  #     # #       #                    ##
##                #### #  #####  ####### #######              ##
##                                                            ##
##                                                            ##
##                                                            ##
##                                                            ##
##                                                            ##
################################################################
################################################################
.fi
.bp
.LP
.ds RH \f3APPEND\f1
.bp
.RE
.ft B
NAME
.ft R
.IP
append \- Anf\o'u"'gen von Tupeln an eine Relation
.RE
.sp 1
.ft B
SYNOPSIS
.ft R
.IP
.ft B
append 
.ft R
[\c
.ft B
to\c
.ft R
] relname (target_list) [\c
.ft B
where 
.ft R
qual\c
]
.RE
.sp 1
.ft B
BESCHREIBUNG
.ft R
.IP
.ft B
append 
.ft R
f\o'u"'gt Tupel
an die mit
.ft B
<relname>
.ft R
bezeichnete Relation an.
Diese Relation muss bereits existieren.
Die
.ft B
<target_list> 
.ft R
bestimmt die
Attribute, die mit Werten belegt werden.
Die Dom\o'a"'nen k\o'o"'nnen in der <target_list>
in beliebiger Reihenfolge aufgez\o'a"'hlt werden.
Attribute, deren Dom\o'a"'ne in der <target_list>
nicht aufgez\o'a"'hlt sind, erhalten einen
leeren Wert (0 bei nume\%rischen Dom\o'a"'nen,
Leerkette "" bei Zeichenketten\-Dom\o'a"'nen).
.IP
Die Belegung der Attribute erfolgt mittels
der Formulierung in der <target_list>
durch direkte Wertzuweisung
oder durch Ausdrucks\- oder Namenszuweisung
aus anderen Quell\-Relationen.
Die Quell\-Relationen sind vorher durch
.ft B
range\c
.ft R
\-Statements mit entsprechenden
.ft B
tuple_variablen
.ft R
zu definieren.
Aus den Quell\-Relationen kann eine Filterung
\o'u"'ber eine
.ft B
where\c
.ft R
\-Phrase erfolgen.
.IP
Das Schl\o'u"'sselwort
.ft B
all 
.ft R
kann in der <target_list>
benutzt werden, wenn der Ziel\-Relation alle
Dom\o'a"'nen hinzugef\o'u"'gt werden
und diese mit den Dom\o'a"'nen\-Namen
der Quell\-Relation \o'u"'bereinstimmen sollen.
.IP
Um Attribute einer numerischen Dom\o'a"'ne zu belegen,
kann ein beliebiges, anderes numerisches Attribut
oder ein nume\%rischer Ausdruck zugewiesen werden.
Es erfolgen automatisch die n\o'o"'tigen Konvertierungen.
Numerische Werte k\o'o"'nnen nicht direkt auf solche
von Zeichenketten\-Dom\o'a"'nen zugewiesen werden;
man konvertiert sie mittels der
.ft B
ascii\c
.ft R
\-Funktion.
Ebenso kann eine Zeichenkette nicht direkt
dem Attribut einer nume\%rischen Dom\o'a"'ne zugewiesen
werden; man benutzt in diesem Fall die
Konvertierungsfunktionen
.ft B
int1
.ft R
,
.ft B
int2
.ft R
u.s.w.
.IP
Das Statement
.ft B
append
.ft R
kann f\o'u"'r die Ziel\-Relation
nur durch deren Eigent\o'u"'mer
oder durch einen Nutzer, der f\o'u"'r sie
die Zugriffsberechtigung
.ft B
append
.ft R
hat, benutzt werden.
.RE
.sp 1
.ft B
BEISPIELE
.ft R
.DS I
/* F\o'u"'ge einer Personal\-Relation
   einen neuen Mitarbeiter hinzu */
append personal(name="Neumann",pno=2345,abt="ORZ")
.sp 1
/* F\o'u"'ge eine Relation zugang
   an die Personal\-Relation an */
range of z is zugang
append to personal(z.all)
.DE
.RE
.sp 1
.ft B
SIEHE AUCH
.ft R
.IP
copy(quel), retrieve(quel)
.RE
.sp 1
.ft B
NACHRICHTEN
.ft R
.IP
Bei Zuweisung eines numerischen Wertes auf das
Attribut einer Zeichenketten\-Dom\o'a"'ne oder einer
Zeichenkette auf das Attribut einer numerischen 
Dom\o'a"'ne werden Nachrich\%ten ausgegeben.
.RE
.sp 1
.ft B
HILFEN
.ft R
.IP
S\o'a"'tze, die einer Ziel\-Relation hinzugef\o'u"'gt werden,
die als heap, cheap, heapsort oder cheapsort
angelegt ist, gelangen auch dann in die Relation,
wenn diese dadurch doppelte Tupel
erh\o'a"'lt.
Bei einer heapsort\- oder cheapsort\-Ziel\-Relation
werden die Tupel eines erfolg\%reichen
.ft B
append
.ft R
hinten angef\o'u"'gt,
sodass die Sortierung 
verloren geht.
.RE
.ds RH \f3COPY\f1
.bp
.ft B
NAME
.ft R
.IP
copy \- Kopieren von Daten einer
Relation von/auf ein \*(xx\-Standard\-File
.RE
.sp 1
.ft B
SYNOPSIS
.ft R
.IP
.ft B
copy
.ft R
relname 
([domname=fformat {, domname=fformat }])
.br
.RS
.IP
direction "Filename"
.RE
.RE
.sp 1
.ft B
BESCHREIBUNG
.ft R
.IP
.ft B
copy 
.ft R
transportiert die Daten zwischen einer \*(yy\-Relation
und einem \*(xx\-Standard\-File.
Ein Tupel der Relation mit seinen Dom\o'a"'nen
wird einem Satz der Datei mit seinen Feldern zugeordnet.
Die Transportrichtung
.ft B
<direction>
.ft R
ist entweder
.ft B
into
.ft R
oder
.ft B
from.
.ft R
Die mit
.ft B
<relname>
.ft R
bezeichnete Relation muss jedenfalls existieren.
Die <domname>'s m\o'u"'ssen
Dom\o'a"'nen dieser Relation sein.
Das ihnen zugeordnete Format
.ft B
<fformat>
.ft R
ist das der Felder des \*(xx\-File.
Das \*(xx\-File muss mit
"Filename"
durch einen kompletten Pfadnamen
(auf der Wurzel, also mit "/" beginnend)
angegeben werden.
.IP
Beim Kopieren in die Relation
(
.ft B
copy
.ft R
<relname>
(...)
.ft B
from
.ft R
"Filename"
)
wird das Statement nur vom Eigent\o'u"'mer der Relation angenommen.
Die Relation darf keine Systemrelation oder
kein Sekund\o'a"'rindex sein
und darf keinen Sekund\o'a"'rindex haben.
.IP
Beim Kopieren in das \*(xx\-File (
.ft B
copy
.ft R
<relname>
(...)
.ft B
into
.ft R
"Filename"
) wird das Statement nur vom Eigent\o'u"'mer der Relation angenommen
oder von einem Nutzer, der f\o'u"'r sie
Zugriffsberechtigung
.ft B
retrieve
.ft R
hat.
Der Nutzer muss die entsprechende Berechtigung
f\o'u"'r das file_directory haben.
Das \*(xx\-File wird mit file_mode 0600
angelegt oder falls es schon vorhanden
ist, neu erzeugt.
Der
.ft B
copy
.ft R
verwendende Nutzer wird Eigent\o'u"'mer des \*(xx\-File.
.IP
Beim Kopieren werden folgende Formate
.ft B
<fformat>
.ft R
f\o'u"'r die Felder des \*(xx\-File
unterst\o'u"'tzt:
.IP
.RS
.IP
.ft B
i1, i2, i4
.ft R
 1\-, 2\- oder 4\-Byte\-Integer
.IP
.ft B
f4, f8    
.ft R
 4\- oder 8\-Byte Gleitkomma
(einfache oder doppelte Genauigkeit)
.IP
.ft B
c1, c2, ... c255
.ft R
 \- Zeichenkette fester angegebener L\o'a"'nge
.IP
.ft B
c0[<delim>] | "c0<delim>"
.ft R
\- Zeichenkette variabler L\o'a"'nge
beendet durch den Begrenzer \c
.ft B
<delim>
.ft R
(delimitor)
.IP
.ft B
d0[<delim>] | "d0<delim>"
.ft R
.br
.ft B
d1 ... d255
.ft R
.br
\- ein f\o'u"'r die Relation bedeutungsloses
Feld (dummy-Feld siehe folgend).
.RE
.IP
Die L\o'a"'ngenangaben in
.ft B
<fformat>
.ft R
d\o'u"'rfen f\o'u"'hrende Nullen haben.
.IP
Die im Statement zugeordnete Dom\o'a"'ne der Relation
zum Feld des File m\o'u"'ssen nicht vom selben Typ
oder derselben L\o'a"'nge sein,
.ft B
copy
.ft R
f\o'u"'hrt die notwendigen Konvertierungen durch
(s. aber unten Laufzeitfehler).
.IP
Im Statement m\o'u"'ssen die Dom\o'a"'nen der Relation
in der Reihenfolge der Felder der S\o'a"'tze des \*(xx\-File
aufgez\o'a"'hlt werden.
Die Zuordnung in der Relation erfolgt per Spaltennamen.
Nicht aufgez\o'a"'hlte Dom\o'a"'nen der Relation
bleiben vom Kopieren ausgeschlossen
(bei
.ft B
from
.ft R
werden sie durch 0 bzw. eine Leerkette "" initia\%lisiert).
Der Satz des \*(xx\-File muss vollst\o'a"'ndig
beschrieben werden.
Vom Kopieren ausgeschlossene Felder m\o'u"'ssen
als
.ft B
dummy\c
.ft R
\-Felder aufgez\o'a"'hlt werden.
Der f\o'u"'r die dummy\-Felder im Statement
angegebene
.ft B
<domname>
.ft R
ist f\o'u"'r die Relation bedeutungslos.
.IP
.ft B
copy
.ft R
unterst\o'u"'tzt die Arbeit mit variabel langen Feldern
auf dem \*(xx\-File, f\o'u"'r die das, sie hinten
begrenzende Zeichen, als Begrenzer (delimitor)
.ft B
<delim>
.ft R
bestimmt werden muss.
Da die \o'u"'blicherweise gew\o'a"'hlten Begrenzer
auch innerhalb der QUEL eine syntaktische Bedeutung haben,
k\o'o"'nnen solche Zeichen symbolisch angegeben werden:
.RE
.DS I
Bezeichner
  f\o'u"'r        bezeichnet
.ft B
<delim>
.ft R
-------------------------------------------------
nl           new_line-Zeichen <nl>
tab          Tabulator-Zeichen <tab>
sp           (space) <blank>-Zeichen
nul          "\e0" Byte vom Wert 0
null         "\e0" Byte vom Wert 0
comma        Komma ","
colon        Semikolon ";"
dash         Bindestrich "-"
lparen       (left  parenthesis) "("
rparen       (right parenthesis) ")"
<zeichen>    das angegebene Zeichen selbst
.DE
.RE
.IP
Man kann das
.ft B
<fformat>
.ft R
auch als
.ft B
"c0<delim>"
.ft R
bzw.
.ft B
"d0<delim>
.ft R
schreiben,
um eine Spezialbedeutung von <delim>
innerhalb von QUEL aufzuheben.
.IP
Bei der Arbeit mit variablen Feldern
sind Besonderheiten abh\o'a"'ngig von der Transportrichtung
zu beachten.
.IP
In die Relation:
.br
.ft B
copy
.ft R
.ft B
relname
.ft R
(...)
.ft B
from
.ft R
"Filename" :
.RS
.IP
Wenn
.ft B
<delim>
.ft R
im Statement bei
.ft B
c0
.ft R
oder
.ft B
d0
.ft R
nicht angegeben ist,
wird das erste auftretende
Komma, <tab> oder <nl>
als Feldbegrenzer gewertet,
sonst begrenzt das angegebene Zeichen <delim>
das Feld.
Das Begrenzerzeichen wird nicht in das Attribut \o'u"'bernommen.
Enth\o'a"'lt das Feld das Begrenzerzeichen an Stellen, wo
es noch nicht Begrenzer sein soll,
ist diesem Zeichen im Feld ein <backslash> ( "\e" )
voranzustellen.

Beispiele:
.DS I
chardom= c0     Zeichenkette endend
                auf Komma, <tab> oder <nl>
chardom= c0nl   dto endend auf <nl>
chardom= "c0#"  dto endend auf #

.DE
Wenn chardom= c0comma definiert ist,
w\o'u"'rde der Feld\%inhalt
.br
	Neumann\e, Karl,
.br
den Attributwert
.br
	Neumann, Karl
.br
erzeugen.

Es wird empfohlen, bei der Anlage von \*(xx\-Files,
die zur Kopie auf \*(yy\-Relationen vorgesehen sind,
einen Satzbegrenzer einzuf\o'u"'hren,
der sich von allen Feldbegrenzern unterscheidet.
Dadurch wird
.ft B
copy
.ft R
synchro\%nisiert,
auch wenn ein Satz f\o'a"'lschlicherweise
nicht die richtige Anzahl von Feldern hat.
.RE
.IP
In das File:
.br
.ft B
copy
.ft R
relname (...)
.ft B
into
.ft R
"Filename" :
.IP
c0	
.br
.RS
.IP
Das Attribut wird in eine Zeichenkette fester L\o'a"'nge
umgewandelt, diese wird in das File geschrieben.
F\o'u"'r die Attribute von Zeichenketten\-Dom\o'a"'nen
ergibt sich die L\o'a"'nge aus dem Dom\o'a"'nen-Format
.ft B
<format>
.ft R
selbst, f\o'u"'r Attribute
numerischer Dom\o'a"'nen erfolgt eine ascii\-Umwandlung
auf das Druckformat, das bei Sitzungsstart
durch die \*(yy\-Optionen
.ft B
-i,
.ft R
.ft B
-f,
.ft R
oder
.ft B
-c
.ft R
beeinflusst werden kann (s.
.ft B
quel\c
.ft R
(unix)).
.RE
.IP
c0<delim>	
.br
.RS
.IP
wie c0, zus\o'a"'tzlich wird das Zeichen <delim>
in das Feld geschrieben.
.RE
.IP
d0	
.br
.RS
.IP
unzul\o'a"'ssig
.RE
.IP
d0<delim>	
.br
.RS
.IP
Das Zeichen <delim> wird einmal in den Satz des File
geschrieben;
der im Statement angegebene <domname> ist bedeutungslos.
.RE
.IP
d1, d2, ... d255	
.br
.RS
.IP
Der <domname> muss einer der oben als "Bezeichner f\o'u"'r <delim>"
aufgez\o'a"'hlten sein.
Das von ihm bezeichnete Zeichen wird 1,2, ... 255 mal
in den Satz des \*(xx\-File geschrieben.
.RE
.IP
d1<delim>, d2<delim>, ... d255<delim>	
.br
.RS
.IP
Das Zeichen <delim> wird 1,2, ...255 mal
in das \*(xx\-File geschrieben.
Der im Statement angegebene <domname>
ist bedeutungslos.
.RE
.RE
.IP
Zur Sicherung und Wiederherstellung
einzelner Relationen kann das Statement in der Kurzform:
.IP
.RS
.IP
.ft B
copy
.ft R
relname ()
direction
"Filename"
.RE
.IP
verwendet werden physiche Kopie = (bulk_copy).
Das Statement wird in diesem Falle automatisch mit allen
Dom\o'a"'nen der Relation in deren Erzeugungsreihenfolge
und deren Formaten erg\o'a"'nzt.
Man spart Formulierungsaufwand, die Abarbeitung
erfolgt schneller als f\o'u"'r andere
.ft B
copy\c
.ft R
\-Statements, da Konvertierungen entfallen.
.RE
.sp 1
.ft B
NACHRICHTEN
.ft R
.IP
Es werden eine Reihe syntaktischer Kontrollen durchgef\o'u"'hrt,
die Fehlernachrichten bringen k\o'o"'nnen
(s.
.ft B
dbu\c
.ft R
(error) 5800 ...),
dabei ist das Kopieren noch nicht angelaufen
(man \o'u"'berpr\o'u"'fe ggf. aber, ob bei copy\.\.\.into
das \*(xx\-create schon das Ziel\-File
gel\o'o"'scht hat).
.IP
Zur Laufzeit f\o'u"'hren folgende Fehler
zum Abbruch des Kopierens:
.RS
.IP -
wenn bei Konvertierungen
(numerisch zu Zeichen\%kette,
Zeichenkette zu numerisch,
numerisch zu numerisch anderen Formats)
die L\o'a"'nge des Ziels eine Aufnahme des
vollst\o'a"'ndigen Wertes nicht mehr erlaubt,
.IP -
wenn bei copy\.\.\.from\ 
das File-Ende asynchron zum Tupelende kommt.
.RE
.IP
Nach Abschluss der Kopie werden 3 integrale Werte
gewarnt, falls es solche F\o'a"'lle gab:
.RS
.IP -
Es wurden
.ft B
nnn
.ft R
Attribute nur verk\o'u"'rzt kopiert.
.RE
.IP
Nur bei copy\.\.\.from\ "Filename":
.RS
.IP -
Es wurden
.ft B
nnn
.ft R
doppelte Tupel gefunden und igno\%riert.
Das erstauftretende Tupel wurde gespeichert.
Diese Meldung tritt nicht auf, wenn die Relation
heap-Struktur hat,
in diese werden auch doppelte Tupel gespeichert.
.RE
.IP -
Es wurden
.ft B
nnn
.ft R
Attribute gefunden,
in denen nicht druckbare Zeichen
auftraten, die zu Leerzeichen konvertiert wurden
(auch <tab>, <nl> und <escape>
wurden konvertiert !)
.RE
.RE
.sp 1
.ft B
BEISPIELE
.ft R
.DS I

/* Kopiere Daten in die personal Relation */

copy personal
(name= "c24#", pno= c4null, d= d0semicol, abt= c0comma
d=d0nl)
from "/mnt/mein_dir/personal"

/* Kopiere Daten der personal Relation
   in ein File */

copy personal
(name= c0comma, pno= i2, comma= d1
abt= c3, d= d1comma, d= d1nl)
into "/user/mein_dir/personal"
.DE
.sp 1
.RE
.ft B
SIEHE AUCH
.ft R
.IP
append(quel), create(quel),
quel(unix), integrity(quel), copyr(unix)
.RE
.sp 1
.ft B
HILFEN
.ft R
.IP
Bei copy into auf Relationen mit definierten 
Integrit\o'a"'ten werden die Integrit\o'a"'ten nicht 
eingehalten, so dass inkonsistente Datenbest\o'a"'nde 
entstehen k\o'o"'nnen.
.RE
.ds RH \f3CREATE\f1
.bp
.RE
.ft B
NAME
.ft R
.IP
create \- Erzeugen einer neuen Relation
.RE
.sp 1
.ft B
SYNOPSIS
.ft R
.IP
.ft B
create
.ft R
relname (domname = format
{, domname = format })
.RE
.sp 1
.ft B
BESCHREIBUNG
.ft R
.IP
.ft B
create 
.ft R
erzeugt eine neue Relation in der aufliegenden Datenbank.
Die Relation wird dem, das Statement ausl\o'o"'senden
Nutzer, zugeeignet (dieser ist ihr "Eigent\o'u"'mer")
und f\o'u"'r 7 Tage reserviert.
Wenn dieser Nutzer der DBA ist,
wird die Relation zur allgemeinen Benutzung (shared),
andernfalls nur f\o'u"'r den Nutzer pers\o'o"'nlich (private)
verf\o'u"'gbar.
Der Name der erzeugten Relation ist
.ft B
<relname>, 
.ft R
ihre Dom\o'a"'nen werden mit den aufgef\o'u"'hrten
.ft B
<domname>
.ft R
\'s angelegt und erhalten die, jeweils f\o'u"'r sie
spezifizierten Formate (s.
.ft B
quel:
.ft R
<format>).
.IP
Die Relation wird als heap ohne Daten initialisiert.
F\o'u"'r andere Nutzer werden keine Zugriffsrechte 
eingetragen.
.IP
Eine Relation kann implementierungsabh\o'a"'ngig 49
bzw. 128 Dom\o'a"'nen bekommen.
Die Namen der System-Relationen
(relation, attribute, indexes, tree, protect, integrities, references)
sind reservierte Relationen\-Namen.
.IP
Die vom Anwender gew\o'a"'hlten Namen m\o'u"'ssen
den \*(yy\-Konventionen gen\o'u"'gen.
Namen d\o'u"'rfen kleine Buchstaben, Ziffern
und das Unterstreichungszeichen "_" enthalten;
m\o'u"'ssen mit einem Buchstaben oder "_" anfangen
und d\o'u"'rfen maximal 12 Zeichen lang sein).
Schl\o'u"'sselworte von QUEL oder AMX sollten vermieden werden.
.IP
Attributnamen sind lokale Namen innerhalb einer
Relation und m\o'u"'ssen hier eindeutig sein.
Relationennamen werden von \*(yy\ mit einem
Codenamen des, sie erzeugenden Nutzers erg\o'a"'nzt.
Ein Nutzer greift dadurch bei gleichen
Relationennamen innerhalb einer Datenbank
immer auf "seine" Relation zu.
.RE
.sp 1
.ft B
BEISPIEL
.ft R
.DS I
/* Erzeuge eine Relation personal
   mit den Dom\o'a"'nen pno, name, abt */
create personal (pno=i2, name=c56, abt=c3)
.DE
.sp 1
.ft B
SIEHE AUCH
.ft R
.IP
append(quel),
copy(quel),
creater(unix),
destroy(quel),
modify(quel),
save(quel)
.RE
.ds RH \f3DEFINE\f1
.bp
.LP
.ft B
NAME
.ft R
.IP
define - definiere ein Subschema
.LP
.ft B
SYNOPSIS
.ft R
.IP
.ft B
define view
.ft R
name (target list) [ 
.ft B
where
.ft R
qual ]
.br
.ft B
define
.ft R
.ft B
permit
.ft R
oplist
.ft B
on
.ft R
var [ (attlist) }
.br
.ft B
to
.ft R
name [
.ft B
at
.ft R
term ] [
.ft B
from
.ft R
time 
.ft B
to
.ft R
time ] [
.ft B
on
.ft R
day 
.ft B
to
.ft R
day ] [
.ft B
where
.ft R
qual ]
.br
.ft B
define integrity on
.ft R
var
.ft B
is
.ft R
qual
.LP
.ft B
BESCHREIBUNG
.ft R
.IP
Mit dem
.ft B
define
.ft R
\-Statement k\o'o"'nnen Integrit\o'a"'ten, Zugriffsrechte
bzw. Sichten (views) in die Datenbank eingef\o'u"'hrt werden,
wenn f\o'u"'r diese QRYMOD (Querymodifikation = Anfragemodifikation)
\-Unterst\o'u"'tzung generiert wurde.
.LP
.ft B
SIEHE AUCH
.ft R
.IP
integrity(quel), permit(quel), view(quel)
.RE
.ds RH \f3DELETE\f1
.bp
.RE
.ft B
NAME
.ft R
.IP
delete \- Streichen von Tupeln aus einer Relation
.RE
.sp 1
.ft B
SYNOPSIS
.ft R
.IP
.ft B
delete
.ft R
var
[\c
.ft B
where
.ft R
qual\c
]
.RE
.sp 1
.ft B
BESCHREIBUNG
.ft R
.IP
.ft B
delete 
.ft R
streicht in der Relation vorhandene Tupel,
die sich unter
.ft B
qual 
.ft R
qualifizieren.
Die
.ft B
<var> 
.ft R
muss in einem vorangehend gegebenem
.ft B
range
.ft R
\-Statement \o'u"'ber einer \%existierenden Relation
definiert worden sein.
Das
.ft B
delete
.ft R
\-Statement hat keine
.ft B
<target_list>, 
.ft R
die sich qualifizierenden Tupel werden insgesamt ge\%strichen.
Wenn im Statement keine where-Phrase angegeben wird,
werden alle Tupel der Relation gestrichen;
es entsteht eine leere Relation.
Will man derartiges erreichen, ist
die Anwendung eines modify-Kommandos
.RS
.IP
.ft B
modify
.ft R
<relname>
.ft B
to truncated
.ft R
.RE
.IP
zeitg\o'u"'nstiger.
.IP
Das
.ft B
delete\c
.ft R
\-Statement wird nur vom Eigent\o'u"'mer der Relation, oder einem
Nutzer, der die
Zugriffsberechtigung
.ft B
delete
.ft R
f\o'u"'r die Relation besitzt,
angenommen.
.RE
.sp 1
.ft B
BEISPIEL
.ft R
.DS I
/* Streichen aller Mitarbeiter der Abteilung ORZ
   aus der Relation personal */
range of p is personal
delete p where p.abt = "ORZ"
.DE
.sp 1
.ft B
SIEHE AUCH
.ft R
.IP
destroy(quel), modify(quel), range(quel)
.RE
.ds RH \f3DESTROY\f1
.bp
.RE
.ft B
NAME
.ft R
.IP
destroy \- L\o'o"'schen von Relationen
.RE
.sp 1
.ft B
SYNOPSIS
.ft R
.IP
.ft B
destroy 
.ft R
relname { , relname }
.br
.ft B
destroy permit | integrity
.ft R
relname
.ft B
all |
.ft R
constraint {,constraint}
.RE
.sp 1
.ft B
BESCHREIBUNG
.ft R
.IP
.ft B
destroy 
.ft R
streicht Relationen aus der aufliegenden Datenbank.
Das Kommando wird nur vom Eigent\o'u"'mer der Relation(en)
angenommen.
Will man von einer Relation nur deren Inhalt
\- also alle Tupel \- streichen,
aber die Defi\%nition der Relation erhalten ,
benutzt man das
.ft B
delete
.ft R
\-Statement ohne where-Phrase
oder das
.ft B
modify
.ft R
\-Statement mit der Speicherstruktur
.ft B
truncated.
.ft R
.IP
Beim Streichen einer Relation,
f\o'u"'r die Sekund\o'a"'rindizes definiert sind,
werden automatisch auch diese gestrichen.
Das Streichen eines Sekund\o'a"'rindex selbst
hat auf dessen Prim\o'a"'r-Relation keine Auswirkung.
.IP
Das
.ft B
"destroy permit"
.ft R
\-Statement l\o'o"'scht gegebene 
Zugriffsrechte zu der Relation "relname", das 
"destroy-integrity"-Statement definierte Integrit\o'a"'ten.
.br
Das Schl\o'u"'sselwort
.ft B
"all"
.ft R
gibt an, dass alle 
Zugriffsrechte bzw. Integrit\o'a"'ten gestrichen werden sollen.
Um einzelne Zugriffsrechte bzw. Integrit\o'a"'ten zu l\o'o"'schen,
muss eine, durch Komma getrennte constraint-Liste (Nummern) 
angegeben werden. Die constraint's erh\o'a"'lt man durch 
.ft B
help permit
.ft R
bzw.
.ft B
help integrity.
.ft R
.RE
.sp 1
.ft B
BEISPIEL
.ft R
.DS I
/* Streiche die Relation personal */
destroy personal
destroy integrity personal 7
destroy integrity personal all
destroy permit personal 2, 9, 12
.DE
.sp 1
.ft B
SIEHE AUCH
.ft R
.IP
create(quel), delete(quel), help(quel), index(quel), modify(quel),
destroyr(unix), integrity(quel), permit(quel), view(quel)
.RE
.sp 1
.ft B
HILFEN
.ft R
.IP
Relationen, die Basis f\o'u"'r Sichten (siehe view(quel))
bzw. Zugriffsrechte (siehe permit(quel)) sind, d\o'u"'rfen 
nicht gel\o'o"'scht werden.
.RE
.ds RH \f3HELP\f1
.bp
.RE
.ft B
NAME
.ft R
.IP
help \- Ausgabe von Hilfen zur Nutzung von \*(yy\
und von Informationen \o'u"'ber die Relationen
der aufliegenden Datenbank
.RE
.sp 1
.ft B
SYNOPSIS
.ft R
.IP
.ft B
help
.ft R
[ relname ] {, relname }
.ft B
help 
.ft R
"" | "section" {, "section"}
.br
.ft B
help view
.ft R
relname {, relname}
.br
.ft B
help permit
.ft R
relname {, relname}
.br
.ft B
help integrity
.ft R
relname {, relname}
.RE
.sp 1
.ft B
BESCHREIBUNG
.ft R
.IP
Mit Statement
.ft B
help
.ft R
ohne Argumente erh\o'a"'lt man eine \o'U"'bersicht \o'u"'ber alle Relationen
der aufliegenden Datenbank, zu denen Zugriffsberechtigung besteht:
.IP
        relation name    relation owner
.br
        { <relname>        <Eigner>   }
.IP
Mit einem Statement
.ft B
help relname
.ft R
erh\o'a"'lt man Informationen \o'u"'ber die
bezeichnete Relation,
sofern f\o'u"'r diese Zugriffsberechtigung besteht:
.RE
.IP
.DS L
 Relation:         <relname>
 Besitzer:         <Eigner der Relation>
 Tupellaenge:      <Gesamtl\o'a"'nge des Tupel>
 saved until:      <Verfallsdatum>
 number of tupels: <Anzahl der Tupel>
 storage structur: <Speicherstruktur>
 relation type:    <Typ der Relation>
         Bei indizierten Prim\o'a"'rrelationen folgt:
 secondary indices: <indexname> {, <indexname>}
         Bei allen Relationen folgt
         die Tabelle ihrer Dom\o'a"'nen:

 Domaenenname Typ  Laenge  Schluessel
 { <domname>       <format>   <keyno>}
.DE
.IP
Die Speicherstruktur wird ausgegeben als:
.RE
.IP
.DS L
 [compressed] (heap          /* [c]heap */
             | isam          /* [c]isam */
             | hash          /* [c]hash */
             | unbekannt [Nummer] /* falsch */
              )
.DE
.sp 1
.IP
Der Typ der Relation ist:
.RE
.IP
.DS L
  Systemkatalog   /* System-Relation*/
 | Index auf <relname>
 | Index auf unbekannte Relation
 | Nutzerrelation  /* Prim\o'a"'rrelation */
.DE
.IP
Die erste Seitenzahl gibt die Anzahl der physischen Seiten, die
die Relation auf externen Speichern belegt und die aufgrund
des Datenbestandes wirklich notwendig sind, aus.
Die 2.Zahl gibt die \o'U"'berlaufseiten an.
.IP
Wenn die Relation einen Schl\o'u"'ssel hat
und dieser aus mehreren Komponenten besteht,
gibt in der Dom\o'a"'nentabelle
eine
.ft B
<keyno>
.ft R
!= 0
an, dass es sich um eine Schl\o'u"'sselkomponente handelt,
gleichzeitig informiert
.ft B
<keyno>
.ft R
\o'u"'ber die Stellung (Reihenfolge) der Komponente im Schl\o'u"'ssel.
.IP
Mit einem Statement
.ft B
help "section"
.ft R
kann man sich einzelne Ab\%schnitte des Referenz-Manuals
ansehen:
.RE
.IP
.DS L
   help ""          zeigt das Inhaltsverzeichnis
   help "help"      zeigt den vorliegenden Abschnitt
   help "<section>" zeigt den Abschnitt <section> dieses
                  Referenz-Manuals
.DE
.IP
Die Abschnittsnamen m\o'u"'ssen
mit kleinen Buchstaben angegeben werden.
.IP
.ft B
help view relname
.ft R
{, relname} druckt die view-Definitionen des spezifizierten Relationsnamen.
.IP
.ft B
help permit relname
.ft R
{, relname} druckt die Zugriffsberechtigungen der spezifizierten
Relationen.
.IP
.ft B
help integrity relname
.ft R
{, relname} druckt die Integrit\o'a"'tsbedingungen f\o'u"'r die
spezifizierten Relationen.
.RE
.ds RH \f3INDEX\f1
.bp
.RE
.ft B
NAME
.ft R
.IP
index \- Erzeugung eines Sekund\o'a"'rindex
.br
        auf eine existierende Relation
.RE
.sp 1
.ft B
SYNOPSIS
.ft R
.IP
.ft B
index on
.ft R
relname 
.ft B
is
.ft R
indexname 
(domname {, domname})
.RE
.sp 1
.ft B
BESCHREIBUNG
.ft R
.IP
.ft B
index
.ft R
wird benutzt, um Sekund\o'a"'rindizes auf existierenden
Relationen zu definieren und zu erzeugen und damit die Effizienz
von
.ft B
retrieve
.ft R
\- und
.ft B
update
.ft R
\-Statements zu erh\o'o"'hen.
Ein Sekund\o'a"'rindex vermittelt mit seinem
Schl\o'u"'ssel einen weiteren Zugriffspfad
auf der Prim\o'a"'r\-Relation, so als
h\o'a"'tte die Prim\o'a"'r\-Relation
einen weiteren Schl\o'u"'ssel, auf den direkt zugegriffen
werden kann.
Der Sekund\o'a"'rindex wird aus den Dom\o'a"'nen der Prim\o'a"'r\-Relation
erzeugt, die in der Reihenfolge,
wie sie im Statement als
.ft B
{<domname>}
.ft R
angegeben sind, als Schl\o'u"'ssel des Index verwendet werden.
Das Statement wird nur vom Eigent\o'u"'mer der Relation
angenommen.
.IP
Um die Integrit\o'a"'t des Index zu erhalten,
kann ein Nutzer Indizes nicht direkt ver\o'a"'ndern.
Sobald die Prim\o'a"'r-Relation ge\o'a"'ndert wird,
werden auch alle auf ihr definierten
Sekund\o'a"'rindizes automatisch ver\o'a"'ndert.
.IP
Ein Sekund\o'a"'rindex wird bei seiner Erzeugung
automatisch in der Speicherstruktur isam
\o'u"'ber seinem Schl\o'u"'ssel
angelegt.
Diese Initialstruktur kann durch die QUEL\-Option
.ft B
\-n
.ft R
auf eine andere festgelegt werden (s.
.ft B
quel
.ft R
(unix)).
Ausserdem kann jeder Sekund\o'a"'rindex
einzeln durch Anwendung eines
.ft B
modify\c
.ft R
-Statements auf eine Speicherstruktur
gebracht werden, die anwendungsspezifisch
die beste ist.
In diesem Falle verwendet man
.ft B
<indexname>
.ft R
wie einen normalen <relname>.
.IP
Nach einem
.ft B
modify
.ft R
\- oder
.ft B
destroy
.ft R
\-Kommando auf einer Prim\o'a"'r\-Relation
sind alle auf ihr definierten Sekund\o'a"'rindizes
gestrichen.
.IP
Sekund\o'a"'rindizes k\o'o"'nnen nicht auf
Systemkataloge, Sichten und
Sekund\o'a"'rindizes definiert werden.
.RE
.sp 1
.ft B
BEISPIEL
.ft R
.DS I
/* Erzeuge einen Sekund\o'a"'rindex abteilung
   auf die Prim\o'a"'r\-Relation personal */
index on personal is abteilung(abt)
.DE
.sp 1
.ft B
SIEHE AUCH
.ft R
.IP
copy(quel), destroy(quel), modify(quel), indexr(unix)
.RE
.sp 1
.ft B
HILFEN
.ft R
.IP
Ein Index kann maximal 6 Dom\o'a"'nen als Schl\o'u"'sselkomponenten
erhalten.
.IP
Das
.ft B
copy\c
.ft R
\-Statement kann nicht benutzt werden,
um Daten in eine Relation zu kopieren,
\o'u"'ber der Sekund\o'a"'rindizes
definiert sind.
.IP
Die Anlage eines Index als isam-Struktur ist
die beste Speicherstruktur f\o'u"'r den Standardfall.
.br
Die Speicherstruktur "heap" ist f\o'u"'r Indizes ohne Sinn,
"hash" ist nur dann sinnvoll, wenn grunds\o'a"'tzlich mit
vergebenen festen Schl\o'u"'sseln \o'u"'ber den Index
recherchiert wird.
.RE
.ds RH \f3INTEGRITY\f1
.bp
.LP
.ft B
NAME
.ft R
.IP
integrity - Definition von Integrit\o'a"'tsbedingungen
.LP
.ft B
SYNOPSIS
.ft R
.IP
.ft B
define integrity on
.ft R
var
.ft B is
.ft R
qual
.LP
.ft B
BESCHREIBUNG
.ft R
.IP
Das 
.ft B
integrity
.ft R
-Statement f\o'u"'gt eine Integrit\o'a"'tsbedingung f\o'u"'r die durch
.ft B
var
.ft R
spezifizierte Relation hinzu.
Eine Integrit\o'a"'t ist eine Einschr\o'a"'nkung eines 
zul\o'a"'ssigen Wertebereiches f\o'u"'r eine oder mehrere 
Dom\o'a"'nen. Nachdem die Integrit\o'a"'ten definiert 
wurden, werden vom System nur noch \o'A"'nderungen 
ausgef\o'u"'hrt, die alle definierten Integrit\o'a"'ten erf\o'u"'llen.
.IP
\o'A"'nderungen, die mindestens eine Integrit\o'a"'t 
verletzen, werden ohne Ausgabe einer Fehlermeldung nicht 
ausgef\o'u"'hrt.
.IP
In der aktuellen Implementation werden Integrit\o'a"'tsverletzungen
nicht ausgewiesen
\- ung\o'u"'ltige Ver\o'a"'nderungen an existierenden
Datenbest\o'a"'nden werden einfach (schweigend) nicht ausgef\o'u"'hrt.
.IP
Die
.ft B
Qualifikation
.ft R
darf keine Aggregate und nur Dom\o'a"'nen 
der einzuschr\o'a"'nkenden Relation enthalten.
.IP
Das integrity-Statement wird nur vom Eigent\o'u"'mer der
Relation angenommen.
.br
In AMX-Programme k\o'o"'nnen nur Relationen verarbeitet
werden, die keine Integrit\o'a"'tsbedingungen besitzen.
.LP
.ft B
BEISPIEL
.ft R
.IP
.DS L
   /* Sichere, dass alle Angestellten ein
      positives Einkommen haben */
   range of e is employee
   define integrity on e is e.salary > 0
.DE
.LP
.ft B
SIEHE AUCH
.ft R
.IP
destroy(quel), copy(quel)
.RE
.sp1
.ft B
HILFEN
.ft R
.IP
Eine Integrit\o'a"'t wird nur dann g\o'u"'ltig, 
wenn der zum Zeitpunkt der Definition existierende 
Datenbestand keine Verletzung der Bedingungen darstellt.
.ft B
copy
.ft R
ber\o'u"'cksichtigt die definierten Integrit\o'a"'ten noch nicht.
.RE
.ds RH \f3MODIFY\f1
.bp
.RE
.ft B
NAME
.ft R
.IP
modify \- \o'A"'nderung der Speicherstruktur einer Relation
.RE
.sp 1
.ft B
SYNOPSIS
.ft R
.IP
.ft B
modify 
.ft R
relname 
.ft B
to 
.ft R
storage_structure
.br
[
.ft B
on 
.ft R
key :sortorder { , key :sortorder} ]
.br
[
.ft B
where 
.ft R
[
.ft B
fillfactor =
.ft R
.ft B
n
.ft R
]
.br
[
.ft B
, minpages = 
.ft R
.ft B
n
.ft R
] [
.ft B
, maxpages = 
.ft R
.ft B
n
.ft R
] ]
.RE
.sp 1
.ft B
BESCHREIBUNG
.ft R
.IP
.ft B
modify
.ft R
ver\o'a"'ndert die Speicherstruktur der spezifizierten
Relation
.ft B
<relname>
.ft R
auf
.ft B
<storage_structur>.
.ft R
Das Statement wird nur vom Eigent\o'u"'mer der Relation
angenommen.
Die Systemrelationen und Sichten k\o'o"'nnen mit
.ft B
modify
.ft R
nicht modifiziert werden.
Das Statement wird benutzt,
um Prim\o'a"'rschl\o'u"'ssel einzuf\o'u"'hren, 
zu \o'a"'ndern bzw. zu reorganisieren.
Die Speicherstruktur
.ft B
<storage_structure>
.ft R
kann wie folgt bestimmt werden:
.IP
.DS L
     isam       - index sequentielle Struktur
     cisam      - komprimierte isam
     hash       - hash Struktur
     chash      - komprimierte hash
     heap       - unstrukturiert und ohne Schl\o'u"'ssel
     cheap      - komprimierte heap
     heapsort   - heap mit sortierten Tupeln
                  und Ausschluss doppelter
     cheapsort  - komprimierte heapsort
     truncated  - heap, in dem alle Tupel gestrichen
                  wurden
     same       - Reorganisation
.DE
.IP
Die Speicherstrukturen isam und hash erm\o'o"'glichen
Schl\o'u"'sselzugriffe.
Isam ben\o'o"'tigt mindestens zwei Plattenzugriffe,
unterst\o'u"'tzt aber auch sequentielle Zugriffe,
wie sie bei von-bis-Abfragen n\o'o"'tig sind.
Hash greift direkt zu, ist aber bei
sequentieller Suche uneffektiv.
Beide Verfahren ordnen neue Tupel zun\o'a"'chst
auf einer Prim\o'a"'rseite ein
und legen, wenn diese voll ist,
dahinter \o'U"'berlaufseiten an.
Bei der Suche nach einem Tupel
f\o'u"'hrt der Direktzugriff auf die Prim\o'a"'rseite,
diese und alle an ihr "h\o'a"'ngenden" \o'U"'berlaufseiten
m\o'u"'ssen nach dem Tupel abgesucht werden.
.IP
Heap ist ein v\o'o"'llig ungeordneter Bestand,
der nur sequentiell durchsucht werden kann.
Heapsort liegt nach
.ft B
modify
.ft R
in einer definierten Sortierfolge vor.
Sowohl bei heap, als auch bei heapsort
werden neue Tupel unsortiert angef\o'u"'gt.
.IP
Bei Anlage einer heapsort-Struktur
werden die Tupel nach allen ihren Attributen sortiert.
Dadurch k\o'o"'nnen und werden doppelte Tupel
ermittelt und ausgeschlossen.
Bei den Speicherstrukturen heapsort bzw. cheapsort 
kann durch die Schl\o'u"'sselw\o'o"'rter 
"ascending" bzw. "a" auf\%steigende und durch die 
Schl\o'u"'sselw\o'o"'rter "descending" bzw. "d"
fallende Sortierung angegeben werden.
.br
"ascending" ist Standard und kann demzufolge entfallen.
.IP
Bei den komprimierten Speicherstrukturen wird eine 
g\o'u"'nstigere Ablage der Daten auf dem externen 
Speichermedium erreicht, mit der Einschr\o'a"'nkung, dass
\o'A"'nderungen unter Umst\o'a"'nden zeitaufwendiger sind.
.IP
Wenn im Statement die
.ft B
on
.ft R
-Phrase fehlt,
wird bei der Modifizierung auf isam, cisam, hash oder chash
als Schl\o'u"'ssel f\o'u"'r die Relation automatisch
die erste Dom\o'a"'ne verwendet.
Bei Modifizierung auf heap, cheap oder same
darf die 
.ft B
on
.ft R
-Phrase nicht angegeben werden.
Bei Modifizierung auf heapsort oder cheapsort
ist die Angabe der
.ft B
on
.ft R
-Phrase notwendig.
.IP
Wenn eine Relation sortiert werden soll
(isam, cisam, hash, chash, heapsort und cheapsort),
sind die Prim\o'a"'rschl\o'u"'ssel der Relation in der
.ft B
on
.ft R
-Phrase in der Reihenfolge der gew\o'u"'nschten
Sortierung anzugeben,
der erstangegebene bildet den dominanten
Sortierbegriff.
Die in der
.ft B
on
.ft R
-Phrase nicht angegebenen Dom\o'a"'nen werden
danach in der erzeugten Reihenfolge
zur Sortierung herangezogen.
.IP
Bei einer Modifikation zur Speicherstruktur "same" wird
die Relation reorganisiert, d.h., die Speicherstruktur, der 
Sortierschl\o'u"'ssel und deren Reihenfolge bleiben erhalten.
Nach umfangreichen \o'A"'nderungen kann die externe
Anordnung der Daten uneffektiv werden, so dass eine 
Neueinrichtung bzw. Reorganisation der Schl\o'u"'sselstruktur
sinnvoll ist.
.br
(Schl\o'u"'sselbaumstruktur !)
.IP
Ein F\o'u"'llfaktor
.ft B
<fillfactor> 
.ft R
spezifiziert die prozentuale F\o'u"'llung (1 ... 100)
der Prim\o'a"'rseiten (unter idealen Bedingungen)
bei Anlage der Relation durch das
.ft B
modify
.ft R
-Statement.
Dieser F\o'u"'llfaktor kann bei Modifizierung
auf isam, cisam, hash und chash angegeben werden.
Man vermeide die Angabe eines zu grossen
F\o'u"'llfaktors bei noch unfertigen Relationen.
Eine ungleichm\o'a"'ssige Verteilung des Schl\o'u"'ssels
kann bei folgenden Erweiterungen der Relation
zur Anlage von vielen \o'U"'berlaufseiten
f\o'u"'hren, wodurch sich das Zugriffsverhalten
der Relation sehr verschlechtert.
.IP
Bei Modifizierung auf hash oder chash spezifizieren
.ft B
minpage
.ft R
und
.ft B
maxpage
.ft R
die minimale und maximale Anzahl von Prim\o'a"'rseiten,
die die Relation haben soll.
Falls angegeben,
m\o'u"'ssen beide mindestens 1 sein;
.ft B
maxpage
.ft R
darf nicht kleiner als
.ft B
minpage
.ft R
sein.
.IP
Wenn nicht angegeben, werden folgende
Standardwerte eingesetzt:
.RE
.DS L
             FILLFACTOR      MINPAGES        MAXPAGES
             ----------      --------        --------
     hash    50              10              nach Bedarf
     chash   75              1               nach Bedarf
     isam    80              --              --
     cisam   100             --              --
.DE
.RE
.sp 1
.ft B
BEISPIEL
.ft R
.IP
.DS L
/* Modifiziere die personal Relation
   auf eine Isam-Struktur mit name als Schl\o'u"'ssel */
modify personal to isam on name

/* Wenn name die erste Dom\o'a"'ne dieser Relation ist
   kann das gleiche Resultat erzielt werden durch */
modify personal to isam

/* Die gleiche Modifizierung
   mit 60-prozentiger F\o'u"'llung der Prim\o'a"'rseiten */
modify personal to isam on name
       where fillfactor = 60
.DE
.DS L

/* Ermittle Dienstjubilare
   und ordne sie nach 10- und 25-j\o'a"'hrigen */
range of p is personal
retrieve into temp
 (p.abt, p.name, dienstalter=1985-p.einstellung)
 where 1985-p.einstellung = 10
      or 1985-p.einstellung = 25
modify temp to heapsort on dienstalter
print temp
destroy temp
.DE
.RE
.sp 1
.ft B
SIEHE AUCH
.ft R
.IP
sysmod(unix), modifyr(unix)
.RE
.ds RH \f3PERMIT\f1
.bp
.LP
.ft B
NAME
.ft R
.IP
permit - f\o'u"'ge Berechtigungen an eine Relation an
.LP
.ft B
SYNOPSIS
.ft R
.IP
.ft B
define
.ft R
.ft B
permit
.ft R
oplist
.ft B
on
.ft R
var [ (attlist) }
.br
.ft B
to
.ft R
name [
.ft B
at
.ft R
term ] [
.ft B
from
.ft R
time 
.ft B
to
.ft R
time ] [
.ft B
on
.ft R
day 
.ft B
to
.ft R
day ] [
.ft B
where
.ft R
qual ]
.LP
.ft B
BESCHREIBUNG
.ft R
.IP
Das
.ft B
permit
.ft R
-Statement darf nur vom DBA f\o'u"'r DBA Relationen
gegeben werden (der DBA kann sich nicht selbst
einschr\o'a"'nken, er hat immer alle Rechte ).
.IP
Das 
.ft B
permit
.ft R
-Statement erweitert die aktuellen Berechtigungen f\o'u"'r eine Relation
entsprechend der Spe\%zifikation von
.ft B
var.
.ft R
Die
.ft B
Operationsliste
.ft R
(oplist) ist eine durch Komma getrennte Liste m\o'o"'glicher
Operationen, also
.ft B
retrieve
.ft R
,
.ft B
replace
.ft R
,
.ft B
delete
.ft R
,
.ft B
append
.ft R
oder 
.ft B
all.
.ft R
"all" ist ein Spezialfall, es bedeutet, dass alle Berechtigungen
gesetzt sind.
.ft B
name
.ft R
ist der login-Name eines Nutzers oder auch "all".
.ft B
term
.ft R
ist ein Terminalname der Form ttyxx oder das Schl\o'u"'sselwort "all".
Das Auslassen der Term-Phrase ist gleichbedeutend zu "all", 
.ft B
xx
.ft R
kann ein implemetationsabh\o'a"'ngiger 2- oder 4- Byte langer Name sein.
.ft B
time
.ft R
ist in der Form "hh:mm" nach 24-Stunden-Modus einzugeben
und begrenzt die Zeit des Tages an der die Berechtigung gilt.
.ft B
day
.ft R
ist die Angabe des Wochentages in der Form 0 = Sonntag 
bis 6 = Sonnabend.
Diese Qua\%lifikation wird an die Qualifikation der Anfrage zur
Laufzeit angeh\o'a"'ngt.
.IP
Die separaten Teile
.ft B
eines
.ft R
permit-Statements ( oplist, attlist, name, term, time- und
day-Phrase und qual ) m\o'u"'ssen gleichzeitig
zutreffen, damit das Zugriffsrecht wirksam wird.
.IP
Die Gesamtzugriffsrechte f\o'u"'r einen konkreten Nutzer 
ergeben sich aus der Menge der Vereinigung aller 
zutreffenden permit-Statements.
Beispielsweise wird mit
.IP
        ... to erich at tty4 ...
.IP
die Berechtigung f\o'u"'r Erich erteilt, wenn er am TTY4 
eingeloggt ist, aber wenn wir zwei
.ft B
 permit
.ft R
-Statements
.IP
        ... to erich at all ...
.br
        ... to all at tty4  ... 
.IP
haben, dann wird Erich die Gesamtheit der Berechtigungen,
die durch das erste Statement gegeben sind (auch am TTYd), nutzen 
k\o'o"'nnen, w\o'a"'hrend Paul alle Berechtigungen des zweiten
Statements nur am TTY4 erh\o'a"'lt.
.IP
Die Statements
.RP
.IP
define permit all on x to all
.br
define permit retrieve on x to all
.RE
.IP
mit keinen weiteren Qualifikationen werden als Spezialf\o'a"'lle
behandelt und sehr effizient aufgel\o'o"'sst.
In AMX-Programmen k\o'o"'nnen
.ft B
nur
.ft R
Relationen verarbeitet werden,
die keine definierten Zugriffsrechte besitzen mit der
Ausnahme der Spezialf\o'a"'lle
.DS L

   define permit all | retrieve on x to all

.DE
ber\o'u"'cksichtigt, alle anderen werden ignoriert.
Die Vergabe von Zugriffsrechten auf Indizes und Sichten ist 
nicht gestattet.
.IP
Die Qualifikation kann Bedingungen aus anderen Relationen enthalten.
.LP
.ft B
BEISPIEL
.ft R
.IP
.DS L
range of e is personal
define permit retrieve on e (name, gehalt) to erich
  at ttyd from 8:00 to 17:00
  on 1 to 5
  where e.mgr = "marc"

range of p is parts
define permit retrieve of p to all
  /*Erich wird die Berechtigung erteilt,
  **\o'u"'ber die Namen der Teile aller Lieferungen
  **des H\o'a"'ndlers 241 zu recherchieren*/
range of t is teile
range of l is lieferung
define permit retrieve on t(tname) to erich
where t.tnum=l.tnum and l.lnum=241
.DE
.LP
.ft B
SIEHE AUCH
.ft R
.IP
destroy(quel)
.RE
.LP
.ft B
HILFEN
.ft R
.IP
Es ist darauf zu achten, dass die Relationen, die in
Qualifikation eingegangen sind, solange nicht gel\o'o"'scht 
werden, solange das Zugriffsrecht existiert.
.RE
.ds RH \f3PRINT\f1
.bp
.LP
.ft B
NAME
.ft R
.IP
print \- Ausgabe von Relationen
.RE
.sp 1
.ft B
SYNOPSIS
.ft R
.IP
.ft B
 print 
.ft R
relname {, relname}
.RE
.sp 1
.ft B
BESCHREIBUNG
.ft R
.IP
.ft B
print 
.ft R
gibt den gesamten Inhalt der spezifizierten
Relation(en) auf das Terminal (standard_output)
aus.
Die Ausgabeformate f\o'u"'r die verschiedenen Formate
der beteiligten Dom\o'a"'nen kann man bei Start von
QUEL durch die entsprechenden Optionen (s.
.ft B
quel
.ft R
(unix)) festlegen. Die als Spalten\o'u"'berschriften
ausgegebenen Namen der Dom\o'a"'nen werden
ggf. abgek\o'u"'rzt, wenn sie anders in der Druckbreite
nicht unterzubringen sind.
.IP
Das Statement wird nur vom Eigner der Relation
oder von einem Nutzer angenommen, der f\o'u"'r sie die
Zugriffsberechtigung
.ft B
retrieve
.ft R
hat.
.RE
.sp 1
.ft B
BEISPIEL
.ft R
.IP
.DS L
/* Ausgabe der Relation personal */
print personal
.DE
.RE
.sp 1
.ft B
SIEHE AUCH
.ft R
.IP
retrieve(quel), 
quel(unix), printr(unix)
.RE
.sp 1
.ft B
HILFEN
.ft R
.IP
Man vermeide die Ausgabe von zu langen Zeilen.
QUEL selbst nimmt keine Zeilenteilung (wrap around) vor.
.RE
.ds RH \f3RANGE\f1
.bp
.RE
.ft B
NAME
.ft R
.IP
range - Deklaration einer tuple_variable'n
.br
        auf eine Relation
.RE
.sp 1
.ft B
 SYNOPSIS
.ft R
.IP
.ft B
range
.ft R
[[
.ft B
of
.ft R
] var
.ft B
is
.ft R
relname ]
.RE
.sp 1
.ft B
BESCHREIBUNG
.ft R
.IP
.ft B
range 
.ft R
wird benutzt, um eine Tupelvariable
.ft B
var
.ft R
, die in nachfolgenden QUEL-Statements benutzt werden soll,
einer Relation
.ft B
<relname>
.ft R
zuzuordnen.
Die
.ft B
var
.ft R
referenziert dann in den QUEL-Statements
jeweils ein Tupel der spezifizierten Relation.
Die Zuordnung der 
.ft B
var
.ft R
zu der Relation
gilt f\o'u"'r die gesamte QUEL-Sitzung,
solange die Variable nicht durch ein anderes
.ft B
range
.ft R
-Statement einer anderen Relation zugeordnet
oder die Relation durch ein
.ft B
destroy
.ft R
-Statement gestrichen wird.
Das leere range-Statement listet die aktuelle range-Tabelle aus.
.RE
.sp 1
.ft B
BEISPIEL
.ft R
.IP
.DS L
/* Deklariere eine tuple_variable p
    auf die Relation personal */
range of p is personal
.DE
.RE
.sp 1
.ft B
SIEHE AUCH
.ft R
.IP
destroy(quel)
.RE
.sp 1
.ft B
HILFEN
.ft R
.IP
Es k\o'o"'nnen nur 10 Tupelvariablen gleichzeitig
dekla\%riert werden.
Nach dem zehnten range-Statement wird durch eine folgende
Deklaration die am l\o'a"'ngsten nicht benutzte
Tupelvariable ung\o'u"'ltig.
.RE
.ds RH \f3REPLACE\f1
.bp
.RE
.ft B
NAME
.ft R
.IP
replace - Ersetzen von Attributen in einer Relation
.RE
.sp 1
.ft B
SYNOPSIS
.ft R
.IP
.ft B
replace
.ft R
var (target_list)
[\c
.ft B
where
.ft R
qual]
.RE
.sp 1
.ft B
BESCHREIBUNG
.ft R
.IP
.ft B
replace 
.ft R
\o'a"'ndert Werte in den Dom\o'a"'nen, die in der
.ft B
<target_list> 
.ft R
angegeben sind f\o'u"'r alle die Tupel, die sich
entsprechend der
.ft B
where
.ft R
-Phrase qualifizieren.
Die
.ft B
var
.ft R
muss in einem vorangehend gegebenem
.ft B
range
.ft R
-Statement \o'u"'ber der zu \o'a"'ndernden Relation
deklariert worden sein.
Ausschliesslich die Dom\o'a"'nen, die modifiziert werden sollen,
m\o'u"'ssen in der
.ft B
<target_list>
.ft R
aufgez\o'a"'hlt werden.
Diese Dom\o'a"'nen k\o'o"'nnen durch Namensangabe bei Zuweisung
eines Ausdrucks, oder durch
Namensanalogie spezifiziert werden.
Attribute in ge\o'a"'nderten Tupeln,
deren Dom\o'a"'ne in der
.ft B
<target_list>
.ft R
nicht aufgef\o'u"'hrt sind,
bleiben unver\o'a"'ndert.
.IP
Attributen numerischer Dom\o'a"'nen kann ein beliebiger
nume\%rischer Wert zugewiesen werden, es erfolgt eine
automatische Konvertierung. Bei der Zuweisung von
Zeichenketten auf Attribute numerischer Dom\o'a"'nen oder
numerischer Werte auf Attribute von Zeichenketten\-Dom\o'a"'nen
muss die Konvertierung durch Verwendung der
entsprechenden Funktionen
.ft B
ascii,
.ft R
.ft B
int1,
.ft R
.ft B
int2,
.ft R
u.s.w.
in der
.ft B
<target_list>
.ft R
angewiesen werden.
.IP
Das Statement wird nur vom Eigner der Relation angenommen,
oder von einem Nutzer, der
eine Zugriffsberechtigung
f\o'u"'r die Relation hat.
.RE
.sp 1
.ft B
BEISPIEL
.ft R
.IP
.DS L
  /* Alle Besch\o'a"'ftigten des Leiters "Rose, Peter"
  **erhalten eine Gehaltserh\o'o"'hung von 10 % */
  range of p is personal
  replace p(gehalt=1.1 * p.gehalt)
  where p.abt="Rose, Peter"
.DE
.RE
.sp 1
.ft B
SIEHE AUCH
.ft R
.IP
range(quel)
.RE
.sp 1
.ft B
NACHRICHTEN
.ft R
.IP
Bei Zuweisung eines numerischen Wertes auf das Attribut
einer Zeichenketten\-Dom\o'a"'ne oder einer Zeichenkette
auf das Attribut einer numerischen Dom\o'a"'ne
erfolgen Fehlermeldungen.
.RE
.ds RH \f3RETRIEVE\f1
.bp
.RE
.ft B
NAME
.ft R
.IP
retrieve - Suche von Tupeln
.RE
.sp 1
.ft B
SYNOPSIS
.ft R
.IP
.ft B
retrieve 
.ft R
[[\c
.ft B
into
.ft R
]relname](target_list) 
[\c
.ft B
where 
.ft R
qual]
.IP
.ft B
retrieve
.ft R
unique (target_list) [
.ft B
where
.ft R
qual]
.RE
.sp 1
.ft B
BESCHREIBUNG
.ft R
.IP
.ft B
retrieve 
.ft R
sucht Tupel mit den Dom\o'a"'nen, wie sie in der
.ft B
<target_list>
.ft R
spezifiziert sind und die den Bedingungen
der
.ft B
where
.ft R
-Phrase gen\o'u"'gen
und gibt sie auf dem Terminal (standard_output) aus
oder speichert sie im Falle von
.ft B
into
.ft R
in die angegebene Relation
.ft B
<relname>.
.ft R
.IP
Wenn
.ft B
<relname>
.ft R
spezifiziert ist, wird eine neue Relation erzeugt, die
in der aufliegenden Datenbank noch nicht
existieren darf.
Beachte, dass verschiedene Nutzer Relationen
gleichen Namens erzeugen d\o'u"'rfen; \*(yy\
erg\o'a"'nzt den Relationennamen um einen, den
erzeugenden Nutzer charakterisierenden Code
(s. auch
.ft B
create
.ft R
(quel).
Der Nutzer wird Eigent\o'u"'mer der Relation.
Die Relation erh\o'a"'lt die, in der
.ft B
<target_list>
.ft R
spezifizierten Dom\o'a"'nen.
Die Relation wird f\o'u"'r 7 Tage reserviert,
falls der Nutzer nicht folgend durch
ein
.ft B
save
.ft R
-Statement die Lebensdauer der Relation ver\o'a"'ndert.
Die Relation wird mit dem Ergebnis des
.ft B
retrieve
.ft R
-Statements gef\o'u"'llt.
.IP
Wenn das Schl\o'u"'sselwort
.ft B
unique
.ft R
spezifiert wird, werden die Tupel nach der Reihenfolge der
angegebenen Dom\o'a"'nen sortiert und doppelte Tupel vor der
Anzeige entfernt.
.IP
Die Resultat\-Relation wird standardm\o'a"'ssig
in
.ft B
cheapsort
.ft R
\-Speicherstruktur
(s.
.ft B
modify
.ft R
(quel))
erzeugt.
Sie wird dadurch nach den Dom\o'a"'nen,
in der Reihenfolge, wie diese in der
.ft B
<target_list>
.ft R
aufgez\o'a"'hlt sind, sortiert
und enth\o'a"'lt keine doppelten Tupel mehr.
.IP
Ist eine andere Speicherstruktur f\o'u"'r die
Resultat\-Relation erw\o'u"'nscht, kann das bei Start
der \*(yy\-Sitzung durch Verwendung der -\c
.ft B
r
.ft R
-Option (s.
.ft B
quel
.ft R
(unix)) erreicht werden.
.IP
Wenn im Statement die
.ft B
into
.ft R
-Phrase fehlt, (also kein
.ft B
<relname>
.ft R
angegeben ist,) erscheint das Resultat des
.ft B
retrieve
.ft R
einmalig auf dem Terminal, es kann nur durch
ein erneutes
.ft B
retrieve
.ft R
wieder sichtbar gemacht werden.
Die Sortierung der ausgegebenen Tupel
folgt den Regeln der Zerlegung der
.ft B
where
.ft R
-Phrase, doppelte Tupel werden nicht
unterdr\o'u"'ckt.
.IP
Die Druckformate, in denen Attribute von Dom\o'a"'nen
der verschiedenen Formate dargestellt werden sollen,
k\o'o"'nnen mit den entsprechenden Optionen
bei Start von \*(yy\ eingestellt werden (s.
.ft B
quel
.ft R
(unix)).
.IP
In der
.ft B
<target_list>
.ft R
kann das Schl\o'u"'sselwort
.ft B
all
.ft R
benutzt werden, wenn von einer Relation
alle Dom\o'a"'nen gesucht werden sollen.
.IP
Das Statement wird nur vom Eigent\o'u"'mer der beteiligten Relation(en)
angenommen, oder von Nutzern, die f\o'u"'r sie die
Zugriffsberechtigung
.ft B
retrieve
.ft R
haben.
.RE
.sp 1
.ft B
BEISPIEL
.ft R
.IP
.DS L
/* Finde alle Mitarbeiter, die j\o'u"'nger sind, als das
   Durchschnittsalter aller Mitarbeiter betr\o'a"'gt */
range of p is personal
retrieve (p.name)
where 1985-p.gebjahr <= avg(1985-p.gebjahr)

/* Finde alle Besch\o'a"'ftigten, die \o'a"'lter
   sind, als ihr Leiter */
range of mitarbeiter is personal
range of leiter is personal
retrieve (mitarbeiter.name)
where mitarbeiter.leiter = leiter.num
and mitarbeiter.gebdat > leiter.gebdat
.DE
.RE
.sp 1
.ft B
SIEHE AUCH
.ft R
.IP
modify(quel), quel(unix), range(quel), 
save(quel)
.RE
.ds RH \f3SAVE\f1
.bp
.RE
.ft B
NAME
.ft R
.IP
save - Reservierung einer Relation bis zu einem Datum
.RE
.sp 1
.ft B
SYNOPSIS
.ft R
.IP
.ft B
save
.ft R
relname 
.ft B
until
.ft R
month day year
.RE
.sp 1
.ft B
BESCHREIBUNG
.ft R
.IP
.ft B
save 
.ft R
wird benutzt, um das Verfallsdatum einer Relation
zu ver\o'a"'ndern,
das
bei ihrer Erzeugung standardm\o'a"'ssig auf 7 Tage
festgelegt wird.
.IP
.ft B
<month>
.ft R
ist der Monat (1,2,..12),
.ft B
<day>
.ft R
ist der Tag (1,2,..31) und
.ft B
<year>
.ft R
ist das Jahr (1985,1986,...)
des neuen Verfallsdatums.
Die Verfallsstunde wird auf 0 Uhr gesetzt.
.IP
Das Streichen einer Relation,
deren Reservierungszeit abgelaufen ist,
erfolgt mit dem Programm
.ft B
purge
.ft R
(s.
.ft B
purge
.ft R
(unix)).
Es erfolgt also nicht automatisch,
sondern nach entsprechenden technologischen
Regelungen \o'u"'ber die Arbeit mit
.ft B
purge.
.ft R
.IP
Ausschliesslich der Eigent\o'u"'mer einer Relation
kann deren Verfallsdatum ver\o'a"'ndern.
.IP
Die Systemrelationen (relation, attribute, indexes usw.)
haben kein Verfallsdatum.
.RE
.sp 1
.ft B
BEISPIEL
.ft R
.IP
.DS L
/* Reserviere die personal Relation
   bis Ende Februar 1987 */
save personal until 3 1 1987
.DE
.RE
.sp 1
.ft B
SIEHE AUCH
.ft R
.IP
create(quel), 
retrieve(quel), 
purge(unix),
saver(unix)
.RE
.ds RH \f3VIEW\f1
.bp
.LP
.ft B
NAME
.ft R
.IP
view - definiere eine virtuelle Relation
.LP
.ft B
SYNOPSIS
.ft R
.IP
.ft B
define view
.ft R
relname (target-list) [
.ft B
where
.ft R
qual ]
.LP
.ft B
BESCHREIBUNG
.ft R
.IP
Eine virtuelle Relation oder Sicht hat im Gegensatz
zu einer normalen Relation (create(quel)) keine 
physische Repr\o'a"'sentation, das heisst, keine eigenen 
Daten. Die Sicht er\o'o"'ffnet anwenderbezogen neue 
Interpretationen existierender Datenbest\o'a"'nde 
( Basisrelationen ).
.IP
Die Syntax des 
.ft B
view
.ft R
-Statements ist der Syntax des
.ft B
retrieve into
.ft R
-Statements angelehnt.
Im Gegensatz zum 
.ft B
retrieve into
.ft R
Statement werden keine Daten recherchiert, sondern nur 
die Recherchen-Definition \o'u"'bersetzt gespeichert.
Wenn die Relation 
.ft B
relname
.ft R
sp\o'a"'ter genutzt wird, wird die Anfrage um die Definition
der Sicht erweitert.
.IP
Alle Formen eines retrieve's auf eine Sicht werden
unterst\o'u"'tzt, aber nur eine begrenzte Anzahl von \o'A"'nderungen.
.RS
.IP 1.
\o'A"'nderungen werden nicht unterst\o'u"'tzt, wenn
die Sicht mehrere Relationen umspannt.
.IP 2.
Es werden keine \o'A"'nderungen unterst\o'u"'tzt, die
auf Dom\o'a"'nen ausgef\o'u"'hrt werden sollen, die a) in der 
Quali\%fikation des
.ft B
define-view
.ft R
\-Statements enthalten sind 
oder b) nicht in einfache Dom\o'a"'nen \o'u"'berf\o'u"'hrt
werden k\o'o"'nnen.
.IP 3.
Allgemein werden \o'A"'nderungen unterst\o'u"'tzt, wenn garantiert werden
kann (ohne Nutzung der aktuellen Daten), dass das Ergebnis
der \o'A"'nderungen der Sicht identisch zu \o'A"'nderungen der
Basisrelation ist.
.RE
.IP
Die Basisrelationen m\o'u"'ssen nicht notwendigerweise 
vom Eigent\o'u"'mer der Sicht angeeignet sein. 
Nutzer, die nicht der DBA sind, erhalten die M\o'o"'glichkeit, 
DBA-Relationen in ihre Sichten einzuschliessen.
Vom System wird garantiert, dass Basisrelationen nicht
gel\o'o"'scht werden.
.RS
.IP zu_2a
.DS L
range of b is base
define view v ( b.all ) where b.dom = 4
append to v ( dom = 5 )
.DE
Das f\o'u"'hrt dazu, dass das Tupel in die 
Basisrelation eingef\o'u"'gt wird, ohne dass es 
Bestandteil der Sicht wird. Die Anomalie besteht
darin, dass Tupel eingef\o'u"'gt werden k\o'o"'nnen, die
nicht angezeigt werden, weil die Qualifikation nicht 
erf\o'u"'llt ist.
.IP zu_2b
.DS L
range of b is base
define view v ( dom = b.dom / 3 )
append to v (dom = 7)
.DE
Dieses append wird in ein append auf ein 
physisches append folgender Art \o'u"'bersetzt:
.DS L
append to base ( dom / 3 = 7 )
.DE
Dieses append ist im Sinne von QUEL nicht akzeptabel.
.IP zu_3:
.DS L
range of b1 is base1
range of b2 is base2
define view v (b1.a, b2.c) where b1.b = b2.b
.DE
Datenbestand:
.DS L

base1 | a  | b     base2 | b  | c     v  | a  | c
~~~~~~|~~~~|~~~~   ~~~~~~|~~~~|~~~~   ~~~|~~~~|~~~~
      | 7  | 0           | 0  | 3        | 7  | 3
      | 8  | 0           | 0  | 4        | 7  | 4
      |    |             |    |          | 8  | 3
      |    |             |    |         >| 8  | 4 <



      range of v is v
      delete v where v.a = 8 and v.c = 4
.DE
Dieses Statement versucht, die markierte Zeile zu 
l\o'o"'schen, was physisch auf den Basisrelationen
base1 und base2 nicht ausf\o'u"'hrbar ist.
.RE
.LP
.ft B
BEISPIEL
.ft R
.IP
.DS L
range of e is employee
range of d is dept
define view empdpt (ename=e.name,e.sal,dname=d.name)
  where e.mgr=d.mgr
.DE
.LP
.ft B
SIEHE AUCH
.ft R
.IP
retrieve(quel), destroy(quel)
.RE
